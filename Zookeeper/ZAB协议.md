# ZAB协议

ZAB（原子消息广播协议）。在Zookeeper中，主要依赖ZAB协议来实现分布式数据一致性。

Zookeeper使用一个单一的主进程来接收并处理所有客户端的**事务请求（也就是一个请求，如果说HTTP请求）**，并采用ZAB的原子广播协议，将服务器的数据状态变更以**事务提议**的方式广播到所有的副本进程上。



**ZAB的核心是定义了事务请求的处理方式，即**

- 所有事务请求都必须由一个全局唯一的服务器来协调处理。这样的服务器被称为Leader服务器，而余下的其他服务器则称为Follower服务器。
- Leader服务器负责将事务请求转化为事务提议（proposal），并将该事务提议分发给所有的Follower服务器。
- Leader服务器需要等待所有Follower服务器的反馈。一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader服务器将向所有的Follower服务器发送commit消息，要求将前一个事务提议刷新到磁盘。



ZAB协议包括2个基本的模式：崩溃恢复 和 消息广播



## 消息广播

ZAB的消息广播过程使用的是原子广播协议，类似于二阶段提交。针对客户端的请求，Leader服务器生成对应的事务提议，并将其发送给集群中所有的Follower服务器。然后收集各自的选票，最后进行事务提交。如图：

![image-20191019134027244](https://tva1.sinaimg.cn/large/006y8mN6gy1g83gfickamj318y0fsn31.jpg)

在ZAB协议中的二阶段提交，移除了中断逻辑。所有的Follower服务器要么正常反馈Leader提出的事务提议，要么就抛弃Leader服务器。同时，我们可以在过半的Follower服务器已经反馈ACK后，就开始提交事务提议了。

Leader服务器会为事务提议分配一个全局单调递增的ID，称为事务ID（ZXID）。由于ZAB协议需要保证每一个消息严格的因果关系，因此需要将每一个事务提议按照其ZXID的先后顺序进行处理。

在消息广播过程中，Leader服务器会为每一个Follower服务器分配一个队列，然后将事务提议依次放入到这些队列中去，并且根据FIFO的策略进行消息发送。

每一个Follower服务器接收到这个事务提议后，会把该事务提议以事务日志的形式写入到本地磁盘中，并且写入成功后，反馈给Leader服务器ACK。

当Leader服务器收到过半Follower服务器的ACK，就发送一个COMMIT消息，同时Leader自身完成事务提交，Follower服务器接收到COMMIT消息后，也进行事务提交。





## 崩溃恢复



### Leader选举

进入技术内幕——》Leader选举



### 数据同步

完成Leader选举之后，在正式开始工作之前，Leader服务器会去确认事务日志中所有事务提议（指已经提交的事务提议）是否都已经被过半的机器提交了，即是否完成数据同步。下面是ZAB协议的 数据同步过程。

Leader服务器为每一个Follower服务器准备一个队列，将那些没有被Follower服务器同步的事务以事务提议的形式逐个发送个Follower服务器，并在每一个事务提议消息后面发送一个commit消息，表示该事务已被提交。

等到Follower服务器将所有其未同步的事务提议都从Leader服务器上面同步过来，并且应用到本地数据库后，Leader服务器就会将该Follower服务器加入到真正可用的Follower列表中。





## 处理丢弃事务



### ZXID的设计

ZXID是一个64位的数字。

其中低32位是一个简单的单调递增的计数器，Leader服务器产生一个新的事务提议的时候，都会对该计数器+1。

高32位，用来区分不通的Leader服务器。具体做法是，每选举产生一个新的Leader服务器，就会从Leader服务器的本地日志中取出一个最大的ZXID，生成对应的epoch值，然后再进行加1操作，之后就会以该值作为新的epoch。并将低32位从0开始生成ZXID。（我理解这里的epoch代表的就是一个Leader服务器的标志，每次选举Leader服务器，那么epoch值就会更新，代表是一个新的Leader服务器）。

ZAB协议中通过epoch编号来区分Leader周期变化，能够有效避免不同Leader服务器使用相同的ZXID。