# 索引



## 概念

索引是存储引擎用于快速查找到记录的一种数据结构。(在MySQL中也叫键)

当表中数据量越来越大时，索引对性能的影响越来越重要。



要理解索引是如何工作的，最简单的方式就是去看一本书的"索引"部分：如果想要在一本书中找到某个内容，一般会先看书的目录（索引），找到对应的页码。

在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应的值(页码)，然后根据匹配的索引记录，找到对应的数据行。假如要运行以下查询：

```mysql
select firt_name from actor where actor_id = 5;
```

如果在actor_id列上面建立了索引，则MySQL先在索引上按值查找，找到actor_id=5的索引记录，然后找到对应的数据行。



索引是有序的



## 索引的原理

![image-20190617215201354](https://ws3.sinaimg.cn/large/006tNc79gy1g44hstelenj31cv0u0qfe.jpg)

B- Tree索引能够加快访问数据的速度，因为存储引擎不再需要全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下查找，通过比较节点页的值和要查找的值，可以找到合适的指针进入下层子节点，最终存储引擎要么是找到对应的值，要么该记录不存在。

![image-20190617225308027](https://ws2.sinaimg.cn/large/006tNc79gy1g44jkcrpwaj31d60oogv0.jpg)

![image-20190617225324395](https://ws4.sinaimg.cn/large/006tNc79gy1g44jkn4mgfj318l0u0h35.jpg)

索引对多个值进行排序的依据是CREATE TABLE语句中定义索引的顺序。看一下最后两个条目，两个人的姓（last name）和名（first name）都一样，则根据他们的出生日期（dob）进行排序。





## MyISAM索引

MyISAM的索引和行记录是分开存储的，叫非聚集索引。

其主键与普通索引没有本质差别：

- 有连续聚集的区域单独存储行记录
- 主键索引的叶子节点存储 主键 与 对应行记录的指针
- 普通索引的叶子节点存储 索引列 与 对应行记录的指针

主键索引与普通索引是独立的两颗B+树，通过索引列查找时，先定位到B+树的叶子节点，再通过指针定位到行记录。



举个例子，MyISAM：

t(id PK, name KEY, sex, flag); 

表中有四条记录：

1, shenjian, m, A

3, zhangsan, m, A

5, lisi, m, A

9, wangwu, f, B

![image-20190623140409869](https://ws1.sinaimg.cn/large/006tNc79gy1g4b1zxydawj31hu0u0dzb.jpg)

其B+树索引构造如上图：

- 行记录单独存储
- id为PK，有一棵id的索引树，叶子指向行记录
- name为KEY，有一棵name的索引树，叶子也指向行记录





## **InnoDB的索引**

InnoDB的**主键索引与**行记录是存储在一起的，故叫做**聚集索引**（Clustered Index）：

- 没有单独区域存储行记录
- 主键索引的叶子节点，存储主键，与对应行记录（而不是指针，*因此，InnoDB的PK查询是非常快的。*）



因为InnoDB的**主键索引与**行记录是存储在一起的，InnoDB的表必须要有聚集索引：

- 如果表定义了PK，则PK就是聚集索引；

- 如果表没有定义PK，则第一个非空unique列是聚集索引；

- 否则，InnoDB会创建一个隐藏的row-id作为聚集索引；



聚集索引，也只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储。

InnoDB的**普通索引**可以有多个，它与聚集索引是不同的：

- 普通索引的叶子节点，存储主键（也不是指针）





对于InnoDB表，这里的启示是：

- 不建议使用较长的列做主键，例如char(64)，因为所有的普通索引都会存储主键，会导致普通索引过于庞大；

- 建议使用趋势递增的key做主键，由于数据行与索引一体，这样不至于插入记录时，有大量索引分裂的同时，有行记录移动；（我的理解是，如果使用趋势递增的key，那么就算引起索引分裂，也只影响到B+树最右边的那一块，从而避免了大量索引分裂）



仍是上面的例子，只是存储引擎换成InnoDB：

t(id PK, name KEY, sex, flag);

表中还是四条记录：

1, shenjian, m, A

3, zhangsan, m, A

5, lisi, m, A

9, wangwu, f, B

![image-20190623141109851](https://ws4.sinaimg.cn/large/006tNc79gy1g4b273jtf6j31d20u07kg.jpg)

其B+树索引构造如上图：

- id为PK，行记录和id索引树存储在一起
- name为KEY，有一棵name的索引树，叶子存储id

 

当：

select * from t where name=‘lisi’;

![image-20190623141138153](https://ws1.sinaimg.cn/large/006tNc79gy1g4b27lfus6j31gx0u01ds.jpg)

会先通过name辅助索引定位到B+树的叶子节点得到id=5，再通过聚集索引定位到行记录。

*所以，其实扫了2遍索引树。*



##两者索引区别总结

MyISAM和InnoDB都使用B+树来实现索引：

- MyISAM的索引与数据分开存储

- MyISAM的索引叶子存储指针，主键索引与普通索引无太大区别

  

- InnoDB的**聚集索引**和数据行统一存储

- InnoDB的聚集索引存储数据行本身，**普通索引**存储主键

- InnoDB一定有且只有一个聚集索引

- InnoDB建议使用趋势递增整数作为PK，而不宜使用较长的列作为PK



## 最左原则

组合索引最左匹配原则是**区分度越高，越靠前**。

这里区分度指的是不同值的数量，数量越多，区分度越高。比如说性别，假设只有男、女两种值，那么区分度就是2，非常低。在这种字段上面建立索引用处不大。



**组合索引，要把区分度高的字段放在前面**

因为where 后面的条件，不在乎先后顺序的。而是按照区分度排序，区分度高的则在前面，排好序之后，再和组合索引进行匹配。因此组合索引，要把区分度高的字段放在前面，才好匹配上。

示例：

```java
SELECT
        count(id)
        FROM
        luck_money_detail
         WHERE  status = 2
                and update_time >= '2019-06-11 10:00:31'
                and update_time <= '2019-07-11 09:50:31'
                    AND amount >= 1
                    AND order_id = '';

这个添加如下索引：
alter table luck_money_detail add index idx_update_time_order_id(update_time,order_id,amount);
```







## 附录



### 二叉树

![image-20190617222802213](https://ws4.sinaimg.cn/large/006tNc79gy1g44iu8mv5hj30fi0bagmr.jpg)

**为什么不适合用作数据库索引？**

- 当数据量大的时候，树的高度会比较高，数据量大的时候，查询会比较慢

- 每个节点只存储一个记录，可能导致一次查询有很多次磁盘IO (我理解是 当读取到这个节点的数据，不在内存中，那么就要进行一次磁盘IO，把该节点的数据拉入内存中。如果遍历很多个节点，并且这些节点都不在内存中，那么就要进行很多次磁盘IO)   (数据库为何不一次拉取多个节点的数据？ 如果一个节点的大小和一页大小相近，那么每次就只能读取一页的数据了)



**磁盘预读**：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，如果未来要读取的数据就在这一页中，可以避免未来的磁盘IO，提高效率。  *通常，一页数据是4K。*





### B- Tree(B树)

- 是m叉搜索树
- 叶子节点，非叶子节点，都存储数据
- 中序遍历，可以获得所有节点(中序遍历的话，是有序的)
- 非根节点包含的关键字个数j满足，**([m/2])-1 <= j <= m-1**，节点分裂时要满足这个条件。

![image-20190617222201242](https://ws4.sinaimg.cn/large/006tNc79gy1g44inzd8irj310c0badiu.jpg)



**B树为何适合做索引？**

- 由于是m分叉的，高度能够大大降低；

- 每个节点可以存储j个记录，如果将节点大小设置为页大小，例如4K，能够充分的利用预读的特性，极大减少磁盘IO(**符合局部性原理**)







### B+ Tree

B+Tree是B树的变种，有着比B树更高的查询性能，来看下m阶B+Tree特征：

- 有m个子树的节点包含有m个元素（B-Tree中是m-1）

- 非叶子节点不再存储数据，数据只存储在同一层的叶子节点上

- 根节点和所有分支节点 
- 都同时存在于子节点中，在子节点元素中是最大或者最小的元素。

- 叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。
- B+树中根到每一个节点的路径长度一样，而B树不是这样。

![image-20190617221912964](https://ws4.sinaimg.cn/large/006tNc79gy1g44il2fefxj31e80acq6t.jpg)

参考：https://www.cnblogs.com/dongguacai/p/7241860.html



### B+ Tree相对B树的优势

- 范围查找，定位min与max之间，中间叶子节点，就是结果集，不用中序遍历查找。(范围查询在SQL中用得很多，这是B+数比B树最大的优势)
- 非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引(从而大大减低数的高度)
- 叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储





###树形

**不管是读请求，还是写请求**，哈希类型的索引，都要比树型的索引更快一些，那为什么，索引结构要设计成树型呢？

索引设计成树形，和SQL的需求相关。



对于这样一个**单行查询**的SQL需求：

select * from t where name=”shenjian”;

确实是哈希索引更快，因为每次都只查询一条记录。



但是对于**排序查询**的SQL需求：

- 分组：group by
- 排序：order by
- 比较：<、>
- …

**哈希**型的索引，时间复杂度会退化为O(n)，而**树型**的“有序”特性，依然能够保持O(log(n)) 的高效率。