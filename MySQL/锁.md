# 锁

锁机制用于管理对共享资源的并发访问。



## lock和latch

在数据库中，lock和Latch都称为锁，但是两者意义不同。

latch称为闩锁（shuang suo），其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又分为mutex互斥锁 和 rwLock读写锁。其目的是为了保证并发线程操作临界资源的正确性。通常没有死锁的检测机制。

lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或者rollback后进行释放。有死锁检测机制。

![image-20190624224512466](https://ws1.sinaimg.cn/large/006tNc79gy1g4cmob7jx6j31eu0fg475.jpg)

通过`show engine innodb mutex`可以查看InnoDB存储引擎的中latch，具体字段详情如下表：

![image-20190624224824680](https://ws1.sinaimg.cn/large/006tNc79gy1g4cmrlfwlqj31go0iial2.jpg)





##锁的类型



### 共享锁、排他锁

InnoDB存储引擎实现了如下两种标准的行级锁：

**共享锁（S Lock）**：允许事务读一行数据

**排他锁（X Lock）**：允许事务删除 或 更新一行数据

如果一个事务T1已经获取了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁。因为读取并不会改变行的数据，所以可以多个事务同时获取共享锁，称这种情况为**锁兼容**。但若有其他的事务T3想获得行R的排他锁，则其必须等待事务T1、T2释放行r上面的共享锁，称这种情况为**锁不兼容**。下面显示了共享锁和排他锁的兼容性：

![image-20190624225847173](https://ws1.sinaimg.cn/large/006tNc79gy1g4cn2e2jqij31bs07kgnq.jpg)

从表6-3可以看出X锁与任何锁都不兼容，而S锁仅和S锁兼容。S锁和X锁都是行锁，兼容是指对同一行记录锁的兼容情况。

普通 select 语句默认不加锁，而CUD操作默认加排他锁。



###记录锁

仅锁定一行记录（如共享锁、排他锁）

- 查询条件的列是唯一索引的情况下，临建锁退化为记录锁



###意向锁

概念：未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向

意向锁有这样一些特点：

（1）意向锁是表级别的锁

（2）意向锁分为： 

- **意向共享锁**(intention shared lock, IS)，它预示着，事务有意向对表中的**某些行**加共享S锁

- **意向排它锁**(intention exclusive lock, IX)，它预示着，事务有意向对表中的**某些行**加排它X锁

（3）意向锁协议：

- 事务要获得某些行的共享锁，必须先获得**表**的意向共享锁IS
- 事务要获取某些行的排他锁，必须先获得**表**的意向排他锁IX

（4）由于意向锁仅仅表明意向，它其实是比较弱的锁，**意向锁之间并不相互互斥，而是可以并行**，其**兼容互斥表**如下：

​          IS          IX

IS      兼容      兼容

IX      兼容      兼容



（5）既然意向锁之间都相互兼容，那其意义在哪里呢？它会与共享锁/排它锁互斥，其**兼容互斥表**如下：

​          S          X

IS      兼容      互斥

IX      互斥      互斥

（排它锁是很强的锁，不与其他类型的锁兼容。这也很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。）





InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细的粒度上进行加锁。如图6-3所示：

![image-20190624230953043](https://ws1.sinaimg.cn/large/006tNc79gy1g4cndxw7kpj31690u07ou.jpg)

若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象上锁，那么首先需要对粗粒度的对象进行上锁。如上图，如果需要对页上的记录上X锁，那么需要分别对数据库A、表、页 上意向锁IX，最后对记录r上排他锁X。

若其中任何一部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，事务T1在对记录r加X锁之前，已有事务T2对表1进行了S表锁，那么表1上面已经存在S锁，之后事务T1试图在表1上加IX锁（获取记录r的X锁必须先获取表1的IX锁），由于不兼容，所以事务T1需要等待事务T2释放表锁。 

![image-20190624233058036](https://ws1.sinaimg.cn/large/006tNc79gy1g4cnzvpmysj31es0c4aeg.jpg)



### 插入意向锁

对已有数据行的**修改与删除**，必须加强互斥锁X锁，那对于**数据的插入**，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。

**插入意向锁**，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。

它的用处是：**多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。**

#### 示例

```mysql
在MySQL，InnoDB，RR下：

t(id unique PK, name);

 

数据表中有数据：

10, shenjian

20, zhangsan

30, lisi

 

事务A先执行，在10与20两条记录中插入了一行，还未提交：

insert into t values(11, xxx);

 

事务B后执行，也在10与20两条记录中插入了一行：

insert into t values(12, ooo);

 

(1)会使用什么锁？

(2)事务B会不会被阻塞呢？

 

回答：虽然事务隔离级别是RR，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：

使用的是插入意向锁

并不会阻塞事务B
```







### 自增锁

在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长计数器的表进行插入操作时，这个这个计数器会被初始化，执行如下操作来得到计数器的值：

`select max(auto_inc_col) from t for update`

插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式成为**Auto-Inc Locking**。这种锁其实是采用一种表锁的机制，为了提高插入的性能，锁不是在一个事务完成以后才释放，而是在完成**对自增长值插入**的SQL语句后立即释放。

虽然**Auto-Inc Locking**从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。

从MySQL5.12版本开始，InnoDB存储引擎提供了一种轻量级互斥量的自增长实现方式。这种方式大大提高了自增长值插入的性能。并且从该版本开始，InnoDB存储引起提供了一个参数innodb_innodb_autoinc_lock_mode来控制自增长模式，该参数的默认值为1。首先看下**自增长的插入分类**，如下图：

![image-20190722221544377](http://ww2.sinaimg.cn/large/006tNc79gy1g58z6a8u5uj31bs0ji7f9.jpg)

下图展示了innodb_innodb_autoinc_lock_mode的不同值对自增的影响：（**值为1、2的时候，看不懂。。**）

![image-20190722221852110](http://ww1.sinaimg.cn/large/006tNc79gy1g58z9hxrxhj31d80rg4gu.jpg)

InnoDB存储引擎中自增长的实现和MyISAM不同。MyISAM存储引擎是表锁设计，自增长不用考虑并发插入的问题。在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列，如果不是第一个列，则MySQL会抛出异常。MyISAM存储引擎没有这个问题。

参考：http://blog.itpub.net/15498/viewspace-2141640/





### 外键与锁

如果没有为外键显示添加索引，InnoDB自动为外键创建索引，这样子避免表锁。

对于外键值的插入或更新，首先需要查询父表中的记录，即select父表。但是不是使用一致性非锁定读，因为这样子会发生数据不一致的问题。因此这时使用的是select…lock in share mode，即主动对父表加一个共享锁。如果这时父表已经加了X锁，子表上面的操作将会被阻塞，如下图：

![image-20190722230035134](http://ww2.sinaimg.cn/large/006tNc79gy1g590gwegmaj31dm0dq78a.jpg)

![image-20190722230121265](http://ww1.sinaimg.cn/large/006tNc79gy1g590hoy3w2j31di0eegw7.jpg)











### MVVC多版本

又称为**一致性非锁定读**。指InnoDB通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行delete或者update操作，这是读取操作不会因此去等待行上锁的释放。相反的，InnoDB存储引擎会去读取行的一个快照数据。

在默认配置下，即事务的隔离界别为**REPEATABLE READ（可重复读）**模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。

快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。

非锁定度机制极大的提高了数据库的并发性。这是InnoDB默认的读取方式，即读取不会占用和带带表上的锁。但是在不同事务隔离界别下，读取的方式不同，并不是在每个事务隔离界别下都是采用非锁定的一致性读。此外，即时都是使用非锁定的一致性读，但是对于快照数据的定义也是各不相同。

快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录可能有不止一个快照数据，一般称这种技术为**行多版本技术**，由此带来的并发控制，称之为**多版本并发控制** MVVC。

在事务隔离界别read committed 和 repeatable read（InnoDB默认的事务隔离界别）下，InnoDB使用非锁定一致性读。然而，对于快照数据的定义却不相同。对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据（如果没有被锁定，则读取行的最新数据；如果行锁定了，则读取该行的最新一个快照）。而在repeatable read事务隔离级别下，对于快照数据，非一致性读总数读取事务开始时的行数据版本。





###一致性非锁定读(见共享锁、排他锁)

在某些情况下，用户需要显式的对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定度操作：

- select … for update

  共享锁(S锁, share locks)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。

​        如果事务对某行数据加上共享锁之后，可进行读写操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。

- select … lock in share mode

​        如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。

select…for update对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。select…lock in share mode对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。

对于一致性非锁定读，即时读取的行已经被执行了select..for update，也是可以进行读取的。

**如果不加筛选条件（或者筛选条件不走索引），会升级为表锁**

**索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。**

参考：https://blog.csdn.net/u012099869/article/details/52778728



