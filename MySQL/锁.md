# 锁

锁机制用于管理对共享资源的并发访问。



## lock和latch

在数据库中，lock和Latch都称为锁，但是两者意义不同。

latch称为闩锁（shuang suo），其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又分为mutex互斥锁 和 rwLock读写锁。其目的是为了保证并发线程操作临界资源的正确性。通常没有死锁的检测机制。

lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或者rollback后进行释放。有死锁检测机制。

![image-20190624224512466](https://ws1.sinaimg.cn/large/006tNc79gy1g4cmob7jx6j31eu0fg475.jpg)

通过`show engine innodb mutex`可以查看InnoDB存储引擎的中latch，具体字段详情如下表：

![image-20190624224824680](https://ws1.sinaimg.cn/large/006tNc79gy1g4cmrlfwlqj31go0iial2.jpg)





##锁的类型



### 共享锁、排他锁

InnoDB存储引擎实现了如下两种标准的行级锁：

**共享锁（S Lock）**：允许事务读一行数据

**排他锁（X Lock）**：允许事务删除 或 更新一行数据

如果一个事务T1已经获取了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁。因为读取并不会改变行的数据，所以可以多个事务同时获取共享锁，称这种情况为**锁兼容**。但若有其他的事务T3想获得行R的排他锁，则其必须等待事务T1、T2释放行r上面的共享锁，称这种情况为**锁不兼容**。下面显示了共享锁和排他锁的兼容性：

![image-20190624225847173](https://ws1.sinaimg.cn/large/006tNc79gy1g4cn2e2jqij31bs07kgnq.jpg)

从表6-3可以看出X锁与任何锁都不兼容，而S锁仅和S锁兼容。S锁和X锁都是行锁，兼容是指对同一行记录锁的兼容情况。



###意向锁

概念：未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向

意向锁有这样一些特点：

（1）意向锁是表级别的锁

（2）意向锁分为： 

- **意向共享锁**(intention shared lock, IS)，它预示着，事务有意向对表中的**某些行**加共享S锁

- **意向排它锁**(intention exclusive lock, IX)，它预示着，事务有意向对表中的**某些行**加排它X锁

（3）意向锁协议：

- 事务要获得某些行的共享锁，必须先获得**表**的意向共享锁IS
- 事务要获取某些行的排他锁，必须先获得**表**的意向排他锁IX

（4）由于意向锁仅仅表明意向，它其实是比较弱的锁，**意向锁之间并不相互互斥，而是可以并行**，其**兼容互斥表**如下：

​          IS          IX

IS      兼容      兼容

IX      兼容      兼容



（5）既然意向锁之间都相互兼容，那其意义在哪里呢？它会与共享锁/排它锁互斥，其**兼容互斥表**如下：

​          S          X

IS      兼容      互斥

IX      互斥      互斥

（排它锁是很强的锁，不与其他类型的锁兼容。这也很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。）





InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细的粒度上进行加锁。如图6-3所示：

![image-20190624230953043](https://ws1.sinaimg.cn/large/006tNc79gy1g4cndxw7kpj31690u07ou.jpg)

若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象上锁，那么首先需要对粗粒度的对象进行上锁。如上图，如果需要对页上的记录上X锁，那么需要分别对数据库A、表、页 上意向锁IX，最后对记录r上排他锁X。

若其中任何一部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，事务T1在对记录r加X锁之前，已有事务T2对表1进行了S表锁，那么表1上面已经存在S锁，之后事务T1试图在表1上加IX锁（获取记录r的X锁必须先获取表1的IX锁），由于不兼容，所以事务T1需要等待事务T2释放表锁。 

![image-20190624233058036](https://ws1.sinaimg.cn/large/006tNc79gy1g4cnzvpmysj31es0c4aeg.jpg)



### 插入意向锁

https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961461&idx=1&sn=b73293c71d8718256e162be6240797ef&chksm=bd2d0da98a5a84bfe23f0327694dbda2f96677aa91fcfc1c8a5b96c8a6701bccf2995725899a&scene=21#wechat_redirect



### 自增锁

自增锁是一种特殊的**表级别锁**（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。

与此同时，InnoDB提供了innodb_autoinc_lock_mode配置，可以调节与改变该锁的模式与行为。

**需要参考《MySQL技术内幕》**



### MVVC多版本

又称为**一致性非锁定读**。指InnoDB通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行delete或者update操作，这是读取操作不会因此去等待行上锁的释放。相反的，InnoDB存储引擎会去读取行的一个快照数据。

在默认配置下，即事务的隔离界别为**REPEATABLE READ（可重复读）**模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。

快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。

非锁定度机制极大的提高了数据库的并发性。这是InnoDB默认的读取方式，即读取不会占用和带带表上的锁。但是在不同事务隔离界别下，读取的方式不同，并不是在每个事务隔离界别下都是采用非锁定的一致性读。此外，即时都是使用非锁定的一致性读，但是对于快照数据的定义也是各不相同。

快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录可能有不止一个快照数据，一般称这种技术为**行多版本技术**，由此带来的并发控制，称之为**多版本并发控制** MVVC。

在事务隔离界别read committed 和 repeatable read（InnoDB默认的事务隔离界别）下，InnoDB使用非锁定一致性读。然而，对于快照数据的定义却不相同。对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据（如果没有被锁定，则读取行的最新数据；如果行锁定了，则读取该行的最新一个快照）。而在repeatable read事务隔离级别下，对于快照数据，非一致性读总数读取事务开始时的行数据版本。





###一致性非锁定读

在某些情况下，用户需要显式的对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定度操作：

- select … for update
- select … lock in share mode

select…for update对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。select…lock in share mode对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。

对于一致性非锁定读，即时读取的行已经被执行了select..for update，也是可以进行读取的。