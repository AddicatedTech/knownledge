# InnoDB



##体系架构

![image-20190804160338041](http://ww2.sinaimg.cn/large/006tNc79gy1g5nph2nbprj312a0owdkl.jpg)

InnoDB存储引擎架构由 内存池 + 后台线程组成。

**内存池**：

- 维护所有进程/线程需要访问的多个内部数据结构
- 缓存磁盘上的数据，方便快速的访问，同时在对磁盘文件进行修改之前，在这里缓存。
- 重做日志（rodo log）缓冲


**后台线程**

主要作用是：

- 刷新内存池中的数据，保证缓冲池中的数据是最新的数据。
- 将已修改的数据文件刷新到磁盘文件。
- 保证在数据库发生异常的情况下，InnoDB能恢复到正常运行状态



### 后台线程

InnoDB是多线程模型，其后台有多个不同的后台线程，负责处理不同的任务



#### Master Thread

master thread是一个非常核心的后台线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页的刷新、合并插入缓冲、undo页的回收。



####IO Thread

InnoDB中大量使用AIO（阻塞IO）处理写IO请求。可以极大提升数据库的性能。而io thread的主要工作是负责这些io请求的回调处理。



#### Purge Thread

事务被提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经使用并且分配的undo页。



#### Page Cleaner Thread

执行 对之前版本脏页的刷新操作。





外键：如果没有为外键显示添加索引，InnoDB自动为外键创建索引，这样子避免表锁。

锁：InnoDB行级锁基于索引实现。



###内存

#### 缓冲池

InnoDB是基于磁盘存储的，并且把记录按照页的方式进行管理。使用缓冲池简单来说就是一块内存区域，通过内存的速度磁盘速度较慢对数据库性能的影响。在数据库中读取页的操作，首先将从磁盘中读取的页放到缓冲池中，下一次再读相同的页时，首先判断该页是否在缓冲池中，若命中，直接读取该页。否则，读取磁盘上面的页。

**对于数据库中页的修改操作，则首先修改在缓冲池中的页**，然后再以一定的频率刷新到磁盘上。注意，页从缓冲池刷新到磁盘的操作并不是在每次页发生变更的时候触发，而是通过一种Checkpoint的机制刷新回磁盘，同样是为了提高数据库性能。

缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。如下图：

![image-20190804163242792](http://ww2.sinaimg.cn/large/006tNc79gy1g5nqbbq8d4j312w0hqjwj.jpg)

LRU列表用来管理已经读取的页，但当数据库刚启动的时候，LRU列表是空的，即没有任何页。这时页都存放在Free列表中。当需要从缓冲池中“分页”（获取一页内存，存放磁盘数据）时，首先从Free列表中查找是否有可用的空闲页，若有，则将该列表从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存分配给新的页。

在LRU列表中的页被修改后，称该页为**脏页**，即缓冲池中的页和磁盘上的页的数据产生了不一致。 这时数据库会通过checkpoint机制将脏页刷新到磁盘。而Flush列表中的页即为脏页。



#### 重做日志缓存

InnoDB首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。

重做日志在下列三种情况会将重做日志缓中的内容刷新到磁盘的重做日志文件中：

（1）Master Thread每一秒将重做日志缓冲刷新到重做日志文件

（2）事务提交时，将重做日志缓冲刷新到重做日志文件

（3）当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件



#### 额外的内存池

在对一些数据结构本身的内存进行分配的时候，需要从额外的内存池中进行申请。





### Checkpoint技术

**Checkpoint（检查点）技术**为了解决如下几个问题：

（1）缩短数据库的恢复时间：

​			当数据库宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页已经刷新都磁盘，因此数据库只要对Checkpoint之后的重做日志进行恢复。这样大大缩小了恢复时间。

（2）缓冲池不够用时，将脏页刷新到磁盘

​			当缓冲池不够用时，LRU算法会算法最近最少使用的页，若此页是脏页，那么需要强制执行checkpoint，将脏页（页的最新版本）刷回到磁盘

（3）重做日志不可用时，刷新脏页

​			![image-20190804181144982](http://ww2.sinaimg.cn/large/006tNc79gy1g5nt6dccv0j31ce0ay47j.jpg)











## 与MyISAM区别

- InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

- InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；

- InnoDB支持数据行锁定，MyISAM不支持行锁定，只支持锁定整个表（表锁）。

- InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而**MyISAM是非聚集索引，数据文件和索引是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。**

  

- InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

- Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；






## InnoDB缓存



###LRU

最近最少使用算法（LRU）是大部分操作系统为最大化页面命中率而广泛采用的一种页面置换算法。该算法的思路是，发生缺页中断时，选择未使用时间最长的页面置换出去。



操作系统，会有**缓冲池**(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。

MySQL作为一个存储系统，同样具有**缓冲池**(buffer pool)机制，以避免每次查询数据都进行磁盘IO。



**InnoDB的缓冲池缓存什么？**

缓存表数据和索引数据



**作用**

把磁盘上的数据加载到**缓冲池**，避免每次访问都产生磁盘IO，起到加速访问的作用。



**为啥不把所有数据都放到缓冲池里**？

因为缓存造价昂贵，存储容量小。因此需要把热数据放到缓冲池中，以最大限度降低磁盘访问。



**什么是预读？**

磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4k），如果未来要读取的数据就在页中，就能从页中直接读取数据，从而省去磁盘IO，提高效率



**预读为什么能有效减少磁盘IO？**

数据访问，通常遵循“局部性原理”（使用一些数据，大概率会使用附近的数据）。“局部性原理”表明提现加载的确是有效的，确实能够减少磁盘IO，因此预读是有效的。



**按页(4K)读取，和InnoDB的缓冲池设计有啥关系？**

（1）磁盘按页读取能够提高性能，所以缓冲池一般也是按页读取（缓冲池中页的大小默认为16KB，也就是说缓冲池一次读取一页数据，相当于读取4页磁盘数据）

（2）按页读取，会使用预读，从而减少未来的磁盘IO



**InnoDB是以什么算法，来管理这些缓冲页呢？**

LRU



**传统的LRU是如何进行缓冲页管理？**

最常见的LRU实现方法：把进入缓冲池的页放入链表头部，作为最近访问的元素，从而最晚被淘汰。这里又分为2种情况：

（1）页已经在缓冲池里面，则把页移动到链表头部

（2）页不在缓冲池中，则从磁盘读取所需要的页，并且放到链表头部。然后把链表末尾的页淘汰掉。

![image-20190803183423353](http://ww1.sinaimg.cn/large/006tNc79gy1g5mo7mhapzj30wg0kktdr.jpg)

![image-20190803183447159](http://ww2.sinaimg.cn/large/006tNc79gy1g5mo81pjd3j30u00boq5w.jpg)





### InnoDB版本的LRU

**传统的LRU缓冲池算法十分直观**，OS，memcache等很多软件都在用，MySQL为什么不直接使用呢？主要是两个原因：

（1）预读失效

（2）缓冲池污染



**什么是预读失效？**

由于预读，提前把页放入到缓冲池，但最终MySQL并没有从该页中读取数据，称为“预读失效”。



**如何对预读失效进行优化？**

要优化预读失效，思路是：

（1）让预读失败的页，尽早从缓冲池中淘汰

（2）让真正被读取的页，尽量在缓冲池中留久一些

具体做法是：

（1）将LRU分为两部分：新生代 和 老年代

（2）新生代首尾相连，即新生代的尾（tail）连接老年代的头（head）

（3）新页加入缓冲池，只加入老年代的头部：

​		a、如果数据被访问，才会加入新生代头部

​		b、如果数据没有被访问，则会比新生代的“热数据页”更早被淘汰出缓冲池

![image-20190803185358586](http://ww1.sinaimg.cn/large/006tNc79gy1g5mos045lqj30ok0i8n0z.jpg)

![image-20190803185433201](http://ww1.sinaimg.cn/large/006tNc79gy1g5moslq4bkj311w0e2tdc.jpg)

![image-20190803185506718](http://ww1.sinaimg.cn/large/006tNc79gy1g5mot6bl76j30rq0f2n0z.jpg)



新老生代改进版LRU仍然解决不了缓冲池污染的问题。



**什么是MySQL缓冲池污染？**

当某一个SQL语句，要扫描大量数据时，可能导致把缓冲池上的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况缓存池污染

例如，有一个数据量较大的用户表，当执行：

select * from user where name like "%shenjian%";

虽然结果集可能只有少量数据，但这类like不能命中索引，必须全表扫描，就需要访问大量的页：

（1）把页加到缓冲池（插入老生代头部）；

（2）从页里读出相关的row（插入新生代头部）；

（3）row里的name字段和字符串shenjian进行比较，如果符合条件，加入到结果集中；

（4）…直到扫描完所有页中的所有row…

如此一来，所有的数据页都会被加载到新生代的头部，但只会访问一次，真正的热数据被大量换出。



**怎么解决这类扫描大量数据导致的缓冲池污染问题呢？**

MySQL加入了一个“老年代停留时间窗口”参数

（1）假设T=老年代停留时间窗口

（2）插入老年代的页，即时被访问，也不会立即放入新生代的头部

（3）只有满足**被访问** 并且 **在老年代停留时间大于T**，才会被放入新生代

![image-20190803193350125](http://ww3.sinaimg.cn/large/006tNc79gy1g5mpxh3gnqj30y20u0490.jpg)

![image-20190803193416421](http://ww4.sinaimg.cn/large/006tNc79gy1g5mpxxma9ij31440te7i2.jpg)



**上述原理，对应InnoDB里哪些参数？**

innodb_buffer_pool_size：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。



innodb_old_blocks_pct：老年代占整个LRU链表长度的比例，默认是37，即整个链表中新生代和老年代的比例是63 ： 37。     *如果把这个参数设为100，就退化为普通LRU了。*



innodb_old_blocks_time：老年代停留时间窗口，单位是毫秒。默认是1000。



**总结**

（1）缓冲池(buffer pool)是一种**常见的降低磁盘访问的机制；**

（2）缓冲池通常**以页(page)为单位缓存数据；**

（3）缓冲池的**常见管理算法是LRU**，memcache，OS，InnoDB都使用了这种算法；

（4）InnoDB对普通LRU进行了优化：

- 将缓冲池分为**老生代和新生代**，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题
- 页被访问，且在老生代**停留时间超过配置阈值**的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题

