# LoadBalance

Dubbo中有四种LB的方式：随机、轮询、最少活跃和一致哈希

接口LoadBalance 的定义说明，LoadBalance 的实现只是在一个服务提供的调用者列表（invokers）中选出一个调用者即可，默认的负载方式是随机负载均衡（@SPI(RandomLoadBalance.NAME)），我们也可以指定使用哪种负载均衡：

```xml
<dubbo:reference interface="xxx" loadbalance="roundrobin"/>  或  <dubbo:service interface="xxx" loadbalance="roundrobin" />
```



### 各种负载均衡的实现方式



### 随机负载均衡（RandomLoadBalance）：

先统计所有服务器上该接口方法的权重总和，然后对这个总和随机nextInt一下，看生成的随机数落到哪个段内，就调哪个服务器上的该服务。



###  轮询负载均衡（RoundRobinLoadBalance）：

如果所有服务器的该接口方法的权重一样，则直接内部的序列计数器（sequences）+1然后对服务器的数量进行取模来决定调用哪个服务器上的服务；如果服务器的该接口方法的权重不一样（就是说存在预热中的服务器），则找到其中最大的权重，然后将内部的权重计数器（weightSequences）+1并对该最大权重数取模，然后再找出权重比该取模后的值大服务器列表，最后通过内部的序列计数器（sequences）+1然后对服务器列表数量进行取模来决定调用哪个服务器上的服务。



### 最少活跃负载均衡（LeastActiveLoadBalance）：

每个接口和接口方法都对应一个RpcStatus对象，记录了他们的活跃数、失败数等等相关统计信息，此种负载均衡方式是在活跃数最低的服务器中对其权重的总和取模来看结果是在哪个权重段中，则选择该服务器来调用，活跃数就像并发量降级中的计数器一样，开始调用时活跃数+1，调用结束时活跃数-1，所以活跃值越大，表明该提供者服务器的该接口方法耗时越长，而消费能力强的提供者接口往往活跃值很低。最少活跃负载均衡保证了“慢”提供者能接收到更少的服务器调用。



### 一致哈希负载均衡（ConsistentHashLoadBalance）：

一致性哈希算法的负载均衡保证了同样的请求（参数）将会落到同一台服务器上，这在某些场景是非常有用的，Dubbo中默认采用了160个虚拟节点，因为Dubbo的请求URL中除了我们使用的参数，还有些额外的系统调用参数，比如timestamp、loadbalance、pid和application等，有人可定会问，Dubbo会对URL中哪些参数进行hash，Dubbo默认除了对我们接口所有参数进行hash外，还会加上这些额外参数，因为有timestamp，这是不是也意味着在Dubbo的重试调用时timestamp不变？

 

### 总结

上述的四种负载均衡，除了一致性哈希，其他三种都依赖了接口方法的权重统计，借助权重的不同，随机负载均衡就能做到动态调整的效果，Dubbo中的轮询负载方式，也利用了权重，那么有人会问，Dubbo中的随机和轮询是不是差别不大？是的，笔者也这样认为，相似的效果，也有着相似的缺点，Dubbo中的随机和轮询负载都没有考虑到提供者服务器消费服务的能力，如果相差很大，“慢”提供者有可能被“快”提供给者给拖垮，其根本原因也是这两种负载均衡的加权因子考虑的不是服务耗时。最少活跃的负载均衡就很巧妙的解决了此问题，而且它不是直接通过统计服务调用的耗时，而是采用统计调用差（活跃数）。一致性哈希特别适用于有缓存的系统，这样缓存命中率会比较高。