# 支付系统



## 支付系统架构

![image-20191021120137035](https://tva1.sinaimg.cn/large/006y8mN6gy1g85otau9pqj30kp0cx409.jpg)

### 支付平台

- 含有提现、转账、充值、退款的基础功能
- 支持和业务后台对接



### 业务后台

比如说红包、扫码收款。



### 第三方回调服务

用于监听微信、支付宝、快钱的回调



###支付网关

用于支付系统和第三方交互的模块



### 资金系统

资金账户系统，资金调整。



### 对账系统

用于内部对账、外部对账



###风控系统

使用Drools规则引擎，制定规则实现风控。



###验证系统

- 生成token，异步推送给客户端

- 验证token是否有效

- 怎么生成token？

  token类型 + 企业账号 +  员工id + 时间戳 + 4位自增数字

- 怎么验证？
  - redis里面有值，即还没有过期
  - key是token，value是是否使用过的标记，如果已经使用过，则验证失败





## 主要功能

### 支付业务

#### 红包

- 发红包：
  - 生成红包业务数据，返回红包id
  - 调用充值接口，生成订单、流水，返回**预支付订单号**
  - 客户端通过**预支付订单号**，调起微信支付
  - 用户支付完成，微信侧回调商户后台
  - 支付平台更新订单、流水状态。并且把这笔钱添加到该用户的冻结金额中
  - 支付平台回调红包业务系统
    - 首先生成n个小红包，（拼手气红包）红包金额随机，并且入库
    - 把这n个小红包的金额放到redis队列中，使用list数据结构实现队列
    - 把大红包（整个红包的数据）存入redis中，用于读操作
    - 调用推送消息给终端，让其展示红包
- 抢红包：
  - 首先从redis队列中出队一个金额
  - 利用hsetnx指令实现分布式锁，向redis中存入小红包的信息（抢红包的人id、抢了红包的金额）
  - 通过MQ调用业务服务
    - 同步抢红包数据到数据库
    - 调用支付平台转账功能（发红包者的冻结金额减少，抢红包者的可用金额增加）
    - 这里MQ起到缓冲的作用，并且保证高可用。
- 红包列表
  - 先查询redis，在查询数据库
- 订单补偿
  - 每隔10分钟，扫描最近30天的红包列表，如果过期，则退款
  - 每隔30分钟，扫描最近30天的**抢红包列表**，抢到红包的话，正常情况下转账订单号不为空。如果转账订单为空，说明支付平台当时可能发生错误了，再次触发转账。



####扫码收款

- 扫码收款（以微信为例子）
  - 获取二维码url
  - 客户端生成二维码
  - 用户扫码二维码，跳转到商户h5页面
  - 输入金额，点击付款
  - 支付平台创建订单、流水
  - 支付平台调用微信接口，生成预支付订单号prepayId
  - 有了prepayId，客户端就可以通过jsapi调起微信支付组件
  - 用户支付成功
  - 微信回调支付平台
  - 支付平台修改订单、流水状态
  - 支付平台回调业务后台
  - 业务后台对业务数据进行处理（比如说 扫码收款有一条业务数据，设置为已完成状态）



###支付平台

#### 提现

#####快钱

概述：使用快钱的**付款到个人银行账户**

流程：用户绑定银行卡——》提现申请——》生成提现订单、流水——》后台审批——》发送提现申请到第三方——》获取提现结果——》修改订单、流水状态



##### 微信

概述：使用企业付款的方式

流程：用户发起提现——》申请生成提现订单、流水——》冻结资金——》后台审批——》发送提现申请到第三方——》获取提现结果——》修改订单、流水状态

参考：https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2



####充值

##### 支付宝

流程：用户发起充值——》生成订单、流水——》拼装URL（支付宝提供给商户的服务接入网关URL：https://mapi.alipay.com/gateway.do? + 业务参数）——》跳转到支付宝——》用户扫码付款——》回调商户后台——》操作资金系统（加钱）——》修改订单、流水状态



#####微信

流程：用户发起充值——》生成订单、流水——》调用微信接口，获取二维码连接——》生成二维码——》用户扫码支付——》微信回调商户后台——》操作资金系统（加钱）——》修改订单、流水状态



####转账

概述：目前只是抢红包使用到转账功能

流程（假设A转账给B）：用户A通过充值发出一个红包——》用户A被冻结了一笔钱X——》用户B抢红包——》用户B生成一个入账订单——》操作资金（分为两步，A的冻结金额减去X，X解冻为已用；B的可用金额增加X）——》操作资金成功的话，修改订单、流水状态。否则，回滚



####退款

概述：红包过期退款、提现审批不通过导致退款。

红包过期退款**流程**：红包过期了，要把剩余金额退还用户——》创建退款订单、流水——》操作资金系统退款（目前toc使用的是微信退款API）——》退款成功，修改订单、流水状态

提现审批不通过导致退款**流程**：审批不通过——》把用户提现的时候冻结的金额解冻——》修改提现订单、流水为**无效订单**的状态。





## 涉及技术



### 分库分表

通过实现主从架构，大大提高并发读的请求，因为可以从从库读数据。并且保障高可用，因为主库挂了，还能够进行主从切换，把某个从库提升为主库。

但是，QPS上来之后，读写请求都增加了：

- 单个节点查询会越来越慢。因为数据量越来越多，索引占用的空间越来越大，那么数据库无法把索引都加载到内存中，只能从磁盘查询索引页，这样影响了查询性能。
- 系统如何处理更高的并发写入请求？

对付这些问题，就可以使用分库分表技术。分库分表技术有垂直拆分、水平拆分。



#### 垂直拆分

咱们的支付系统也采用了垂直分库，所谓的垂直分库，就是按照业务来划分表，比如说用户表和订单表就分离开来，放在不同的数据库中，并且这些数据库单独放置在不同的物理机器上，让不同业务表充分使用其机器IO和内存等资源。如果垂直分库还不满足并发需求了，这时候就用上水平拆分。

- 通过把不同业务的数据拆分到不同数据库节点上，这样某个节点发生故障时，只影响该节点的功能。当然，每个节点都通过主从架构来保障高可用，所以这种情况基本不会发生。
- 对数据库进行垂直拆分是比较常使用的。



#### 水平拆分

通过垂直拆分，将不同业务的表分离到不同数据库节点上，但是单个表如果数据量很大，还是扛不住大量的读写请求，这时候就可以使用水平拆分技术。

咱们公司的水平拆分使用**sharding-jdbc框架**来实现。具体为，订单系统使用sharding-jdbc进行分片，根据订单号来进行分表，分为15张表。订单号作为全局唯一ID。

**查询单个数据**：查询数据的时候，先通过订单号进行hash，判断数据在哪一张表上，然后去该表上进行查询。

**h5分页查询**：通过时间戳倒序分页查询数据，在sharding-jdbc中会实现为把请求转发到每张表上，通过where条件筛选出满足的数据列表，比如说每张表都筛选出20条数据，这些数据都小于lastId，然后做一次合并操作，那么15张表，就有20*15=300条数据，这300条数据在内存中根据创建时间排序，并且进行倒序，然后取出前面20条件，就是咱们需要的数据。

**分页查询**：需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。

![image-20191123112742668](https://tva1.sinaimg.cn/large/006y8mN6gy1g97ta87otrj30zm0oy7gs.jpg)

上图中只是取第一页的数据，对性能影响还不是很大。但是如果取得页数很大，情况则变得复杂很多，因为各分片节点中的数据可能是随机的，为了排序的准确性，**需要将所有节点的前N页数据都排序好做合并**，最后再进行整体的排序，在取出偏位位置的那一页，这样的操作时很**耗费CPU和内存资源的**，所以页数越大，系统的性能也会越差。

参考：[分库分表](https://cloud.tencent.com/developer/article/1464281)



#### 全局唯一性ID

**咱们系统目前的方案**

咱们的订单系统使用订单号来作为分区键，订单号是一个32位的字符串是如下格式：

2位的业务前缀 + 1位的订单号版本 +  4位预留 + 4位用户账号 + 17位时间戳（毫秒级） + 4位自增号

- 业务前缀表示该订单是哪一类业务。使得订单号具有业务相关性，这样子找问题也比较简单。
- 订单号版本表示这个订单是哪个版本，比如我现在使用第一版的订单号格式，后面可能还会出第二版的订单号格式。
- 自增号到9999之后，会重新变为1开始。



**其他方案：通过雪花算法改进**

除了我公司目前的做法，我觉得还可以采用雪花算法。





### redis缓存

红包通过将热数据（也就是还没有过期的红包）放到redis中，当抢红包的时候，一大波写请求过来，TPS异常高，通过redis缓存 + 消息堆里rocketMQ 抗住压力。

当抢红包的请求过来时，用户抢红包数据先更新到redis中，成功更新则说明抢到红包，通过hsetnx实现分布式锁，保证抢红包的数据正确性。

更新完redis的数据后，发送MQ消息，通知另外一个业务服务去进行转账操作、并且更新红包数据库信息。这里MQ起到了一个缓冲的作用，因为更新数据库的请求首先会在MQ消息队列中进行排队。当数据库中红包数据也被标志为已抢，那么数据不一致的问题也解决了。

由于咱们发红包，抢红包的热数据都在redis中，接来下用户访问这些热数据通过redis来访问，能大大提高读写性能，减少数据库压力。





#### 红包补偿机制

红包过期了，怎么返还金额；抢红包完成后，需要通过支付平台将发红包账户的钱转移到抢红包账户中，那么假如这个过程出故障了，怎么保障系统自动修复，继续运行？

- 定时扫码过期的红包，如果已经过期了，就把冻结的剩余金额退款到用户账户上
- 定期扫码转账订单号为空的红包，这些红包是抢红包之后转账失败的，那么就是重新发起转账流程





### 灰度发布

使用gray-provider灰度系统



### 流量控制

**基于阻塞队列queue的offer实现**

原理，初始化队列，默认长度（可同时并发执行的数量），每一个请求进来时，往队列放置一个对象，如果队列已满，则等待，然后超时。请求执行完后，释放队列位置。

使用方式：

1. 配置流控aop 

2. 在需要流控限制的接口上配置注解 





### 支付安全

- **数据安全**：
  - 将敏感数据采用AES加密后存储；读取的时候，采用AES解密。
- **通讯安全**：
  - 使用HTTPS加密
  - 传递的参数需要进行验签
- **资金安全**：
  - 风控：使用Drools规则引擎，制定规则实现风控。
    - 每天提现次数不能超过3次
    - 每天提现金额不能超过1万
  - 对账：
    - 外部对账：每天凌晨2点，下载第三方的前一天的账单，和内部账单进行金额对比。
    - 内部对账：校验每家企业，计算规则为   充值+收入 -提现 -消费 = 余额
- **身份认证**：
  - 商户身份验证：登录账户的密码校验
  - 快钱银行卡身份认证
  - 手机验证码验证
- **Token验证**
  - 目的是：避免抓包重放
  - 开始执行业务请求之前，客户端向Validator服务获取token
  - Validator服务异步推送token。之所以采用异步推送的形式，是为了防止脚本恶意获取Token。因为只有咱们的客户端才能使用异步推送。
  - 客户端携带token到后台进行校验（token是否在有效期、是否被使用过），校验通过，执行业务逻辑。





## 价值

- 为用户提供可靠的支付服务
- 支持快速接入新的支付业务



## 发展方向

- 互联支付（上游展示收款码，下游进行支付）



## 问题

**支付系统的QPS及如何抗住高并发？**

咱们拆红包的峰值QPS是2000。做了如下措施：

- 抢红包瞬间是纯内存操作，能支撑大量并发请求
  - 采用2台16G的机器作为专用Redis机器节点
  - 单个红包数据约占50字节，内存中2000万个红包，总内存占用基本在2G左右，内存是足够的
- Redis Cluster集群、sentinal保证缓存高可用
- RocketMQ异步入库
- 采用Dubbo服务拆分，将不同模块单独配置在机器上，充分利用机器的CPU和内存
- 分库分表
  - 垂直拆分
  - 水平拆分
- 使用SSD固定硬盘，作为数据库存储
- 监控系统告警





**如果抢红包的时候，redis挂了，怎么处理？**

从数据库中拉取所有小红包数据，恢复到redis中。可以恢复，但是会多一次缓存miss。



**支付平台回调过程中有哪些参数？**

商品号（唯一标识一个业务）、订单号、金额、请求时间、订单状态





## 参考

快钱企业人民币网关，对应我们的充值业务   https://wenku.baidu.com/view/06ff0e68998fcc22bdd10d5a.html

