# GC垃圾回收

JVM的垃圾回收机制，在内存充足的情况下，除非你显式调用System.gc()，否则它不会进行垃圾回收；在内存不足的情况下，垃圾回收将自动运行



 ## 判断对象是否要回收的方法

**可达性分析法**



### 概念

可达性分析法：通过一系列“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，并且root对象引用的对象也是不可回收的）



**以下对象会被认为是root对象**

- 虚拟机栈（栈帧中本地变量表）中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中Native方法引用的对象



 **对象被判定可被回收，需要经历两个阶段**

- 第一个阶段是可达性分析，分析该对象是否可达。**从堆和静态存储区开始，遍历所有引用，就能找到所有的对象。对于发现的每个引用，必须追踪它引用的对象，然后是此对象包含的所有引用，如此反复进行，直到”从堆栈和静态存储区出发的引用“所形成的网络全部被访问为止。**

- 第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。（finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会）



### 方法区中的垃圾回收

方法区主要回收的内容有：**废弃常量和无用的类**。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的`ClassLoader`已经被回收；
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

**这里解释下为什么需要回收该类的ClassLoader？**

```java
public Class<?> getDeclaringClass() throws SecurityException {
        final Class<?> candidate = getDeclaringClass0();
  /*
  * 反射里面使用到ClassLoader，因此要把ClassLoader干掉，才能保证没有地方可以通过反射调用到Class类。
  * 然后当类的实例都会被回收了，并且该类没有在任何地方被引用到了，那么这个类就可以被回收了
  */
  if (candidate != null)
  candidate.checkPackageAccess(
  ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
  return candidate;
}
```





### finalize()

（1）   GC垃圾回收要回收一个对象的时候，调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。

（2）   可以在该方法里面，指定一些对象在释放前必须执行的操作。

   

**发现虚拟机频繁full GC时应该怎么办**

（full GC指的是清理整个堆空间，包括年轻代和永久代）

（1）   首先用命令查看触发GC的原因是什么 jstat –gccause 进程id

（2）   如果是System.gc()，则看下代码哪里调用了这个方法

（3）   如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令

（4）   如果是GC locker，可能是程序依赖的JNI库的原因

 

##常见的垃圾回收算法

### 引用计数

是一个简单但是速度很慢的垃圾回收计数。每个对象含有一个引用计数器。当有引用连接对象时，引用计数加1。当对象离开作用域时，引用计数减1。所有的引用计数器都会存放在一个列表中，垃圾回收器会在这个列表上进行遍历，当发现某个对象的引用计数为0时，就释放其占用空间。

缺点：存在循环引用的情况，导致2个循环引用对象的内存得不到释放。目前没有一个JVM的垃圾回收实现是使用这个算法的。



### Mark-Sweep（标记-清除算法）

#### 思想

标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。



#### 优缺点

实现简单，容易产生内存碎片



### Copying（复制算法）

#### 思想

将堆划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，先暂停程序，找出存活对象，然后把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。

当对象被复制到新堆的时候，它们是一个挨着一个的，所以新堆保持紧凑排列。

当把对象从一处搬到另外一处时，所有指向它的那些引用都必须修正。（将旧地址映射到新地址）

#### 优缺点

- 不容易产生内存碎片
- 可用内存空间少
- 如果要回收的对象很少，采用这种方法会很浪费



### Mark-Compact（标记-整理算法）

#### 思想

从堆和静态存储区出发，遍历所有引用，进而找出所有存活对象。每当找到一个存活对象，就会给对象设置一个标记，这个过程不会回收任何对象。只有标记工作全部完成的时候，清理动作才会开始。在清理的过程中，没有标记的对象会被释放，不会发生任何复制动作。所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。

#### 优缺点

- 不容易产生内存碎片
- 内存利用率高

- 存活对象多并且分散的时候，移动次数多，效率低下
- 程序暂停

 

### 分代收集算法

#### 思想：

只是根据对象的存活周期的不同把堆分成新生代和老年代（永久代指的是方法区），这样就可以根据各个年代的特点采用最适当的收集算法。

“分代收集”是目前大部分JVM的垃圾收集器所采用的算法。

##### 新生代

-  在新生代里面存放的是存活时间比较短的对象，如某一个方法的局域变量、循环内的临时变量等等
-  在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
-  新生代里面分成一份较大的Eden空间和两份较小的Survivor（存活）空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor空间中，清空Eden和刚才使用过的Survivor空间。
-  一块Eden和一块Survivor区，比值为8：1。这样子的设置是有原因的。新生代采用复制算法，如果单纯的把内存分为2块，由于存活对象很少，那么存放存活对象的那块堆内存，会有很多内存浪费。因此，使用两块10%的内存作为空闲和活动区间（两块Survivor区），而另外80%的内存（Eden区），则是用来给新建对象分配内存的。一旦发生GC，将10%与另外80%的活动区间 中存活的对象转移到10%的空闲区间，接下来，将之前90%的内存全部释放。
-  绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快

![20160730141640502](https://ws1.sinaimg.cn/large/006tKfTcgy1g0hgrqg3hij30x80fygpa.jpg)



**新生代垃圾回收流程**

- 当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）
- 此后，每次Eden区满了，就执行一次Minor GC，并将Eden剩余的存活对象都添加到Survivor0
- 当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，然后清理掉Survivor0区。之后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。重复上述步骤，只不过这次是Eden区和Survivor1区配合。

Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活 着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方 式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”法），这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。



##### 老年代（tenured）

-  存放的是存活时间比较长的对象，如缓存对象、数据库连接对象、单例对象等等
-  老年代中因为对象存活率高、没有额外空间对它进行分配担保，就只能使用“**标记-清除**”或“**标记-整理**”算法来进行回收。
-  在新生代里的每一个对象，都会有一个年龄，当这些对象的年龄到达一定程度时（年龄就是熬过的GC次数，每次GC如果对象存活下来，则年龄加1），则会被转到年老代，而这个转入年老代的年龄值，一般在JVM中是可以设置的。



##### 永久代

-  在堆区外有一个永久代，
-  对永久代的回收主要是无效的类和常量，并且回收方法**同老年代**。



### GC使用时对程序的影响 

垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，然后释放没用对象，这个过程消耗处理器时间



### 几种不同的垃圾回收类型

#### Minor GC

从年轻代（包括Eden、Survivor区）回收内存。

- 当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC

- 执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。



#### Major GC

清理整个老年代，当eden区内存不足时触发。



#### Full GC

清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发



## finalize

- 一旦垃圾回收器准备好释放对象占用的内存空间，将首先调用其finalize()方法，并且在下一次垃圾回收的时候，才会真正回收对象占用的内存。

- **finalize不能作为通用的清理方法**：首先明确一个要点：**如果java虚拟机并未面临内存耗尽的情景，它是不会浪费时间去执行垃圾回收的**。假设把清理操作放到finalize方法中，然后对象没有被使用了，但是内存充足，导致垃圾回收器没有回收，因为对象可能不会被垃圾回收，因此也就不会调用finalize()，清理操作得不到执行。

- finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性

- **用处**：

- - **释放垃圾回收器不能释放的内存**：由于分配内存时，可能采用了类似C语言中的做法，而非Java中的通用做法。比如说某个地方利用本地方法调用C语言的malloc()方法分配内存空间，因此垃圾回收器不会回收这部分空间（垃圾回收器只会回收new的对象的内存空间），这时候，就要在finalize()方法中利用本地方法调用free函数，来释放内存空间。（即使是这个用处，也依赖了垃圾回收器的执行）  

  - **验证终结条件**：利用finalize()可以发现一些对象没有被正确清理的对象。如下程序：

    ```java
    public class HYFinalize {
    
    
        public static void main(String[] args) {
            Book book = new Book(true);
    
            book.checkIn();
    
            // 每一本书都应该进行checkIn操作，从而释放内存。
            // 这本书没有进行 checkIn操作，因此，没有执行清理操作(没有输出finalize execute)。也就是利用finalize方法进行终结验证，从而找出没有释放对象的内存。
            new Book(true);
    
            // 手动调用垃圾回收
            System.gc();
        }
    
    }
    
    class Book {
        boolean checkOut;
    
        public Book(boolean checkOut) {
            this.checkOut = checkOut;
        }
    
        void checkIn() {
            checkOut = false;
        }
    
        @Override
        protected void finalize() throws Throwable {
            super.finalize();
    
            if (checkOut) {
                System.out.println("finalize execute");
            }
        }
    }
    ```

    

- java不允许创建局部对象，也就是java不允许在堆栈中创建对象。java创建对象只能在堆中创建。





## 参考

https://blog.csdn.net/mccand1234/article/details/52078645

重点：  https://www.cnblogs.com/aspirant/p/8662690.html、https://www.cnblogs.com/aspirant/category/1195271.html

[https://www.cnblogs.com/1024Community/p/honery.html#25-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6](https://www.cnblogs.com/1024Community/p/honery.html#25-方法区如何判断是否需要回收)