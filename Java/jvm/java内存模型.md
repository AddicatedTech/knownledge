### 内存可见性

线程无法立即看到另外一个线程的操作结果，原因可能如下：

- 在编译器中生成的指令顺序，可能与源代码中的顺序不同
- 编译器可能把变量保存在寄存器而不是内存中
- 处理器可以采用乱序和并行等方式来执行指令
- 缓存可能会改变 将写入变量 提交到内存的顺序（todo **这个还不懂，先留着**）
- 保存在处理器本地缓存中的值，对于其他处理器是不可见的



**寄存器**

CPU内部的元件，所以在寄存器之间的数据传送非常快。用途：

- 可将寄存器内的数据执行算术及逻辑运算。
- 存于寄存器内的地址可用来指向内存的某个位置，即寻址。
- 可以用来读写数据到电脑的周边设备。



**处理器本地缓存**

是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。

高速缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据到来或把数据写入内存。

在缓存中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先缓存中调用，从而加快读取速度。



### 重排序

概念：是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。

优点：提高执行效率

缺点：在多线程环境下，如果调度器采用不恰当的方式来交替执行不同线程的操作，那么将导致不正确的结果。（同步将限制编译器、运行时环境对内存操作的重排序方式，从而在实施重排序时不会破坏可见性保证）



### Java内存模型

概念：Java的内存模型是通过各种操作定义的，包括对变量的读/写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。JMM为程序中所有操作定义了一套偏序关系，称之为**Happens-Before**。要想保证执行操作B的线程看到操作A的结果（无论A和B是否在同一个线程中执行），那么A和B之间必须满足Happens-Before关系。如果两个操作之间缺乏Happens-Before关系，那么JVM可以对它们任意的进行重排序。



#### Happens-Before规则：

- 程序顺序规则：如果程序中操作A在操作B之前，那么在线程中，操作A将在操作B之前执行
- 锁规则：在锁上的解锁操作必须在同一个锁上的加锁操作之前执行（一个锁处于被锁定状态，那么必须先执行解锁，才能执行加锁）
- volatile变量规则：对volatile变量的写入操作需要在读操作之前执行
- 线程启动规则：在线程上对Threasd.start调用必须在线程执行任何操作之前执行（假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见）
- 线程结束规则：线程中任何操作都必须在 其他线程检测到该线程已经结束 之前执行 （假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见）
- 中断规则：当一个线程在另一个线程上调用Interrupted，必须在被中断线程检测到Interrupted之前
- 终结器规则：对象的构造函数必须在启动该对象的终结器（finalize方法）之前执行完成
- 传递性：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。



![image-20190209162746951](https://ws2.sinaimg.cn/large/006tNc79gy1g0093zu470j30e40d80ui.jpg)

线程B和线程A在同一把锁上面进行同步，满足Happens-Before关系，因此可以推断它们之前动作的顺序，并且A的所有操作的结果，对于B是可见的。



上面八条是原生Java满足Happens-before关系的规则，但是我们可以对他们进行推导出其他满足happens-before的规则：

- 将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作
- 将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作
- 在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作
- 释放Semaphore许可的操作Happens-Before获得许可操作
- Future表示的任务的所有操作Happens-Before Future#get()操作
- 向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作



再重述一遍Happens-before的概念：

如果两个操作不存在上述（前面8条 + 后面6条）任一一个Happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序。如果操作A happens-before操作B（操作A发生在操作B之前），那么操作A在内存上所做的操作对操作B都是可见的。

**happen-before原则是JMM中非常重要的原则，它是判断数据是否存在竞争、线程是否安全的主要依据，保证了多线程环境下的可见性。**



参考：https://www.cnblogs.com/chenssy/p/6393321.html



#### 监视器

在Java中，每个对象和Class内部都有一个锁，Class广义上也是一个单例对象，每个对象和Class会和一个监视器关联，注意措辞，锁是存在于对象内部的数据结构，监视器是一个独立的结构但是和对象关联，相同点是对象一定有一个锁也一定关联一个监视器。另外，**监视器是操控线程的，他会维持一个代码数据区和线程队列等，保证同一时刻只有一个线程访问代码数据区**，监视器就是通过判断对象里锁来完成这个安全访问的功能的。

监视器是比锁更高层次的抽象。具体的操作流程是：当代码进入同步区域时，找到对象关联的监视器，然后调用监视器获取锁的方法，监视器会读取对象头里面有关锁的信息作为参数，然后进行获取锁的操作，或是让当前线程得到锁，或是让当前线程等待，当代码退出同步区域时，找到对象关联的监视器，然后调用监视器释放锁的操作，整个流程大致是这个样子。

参考：https://blog.csdn.net/tales522/article/details/80853489



#### 借助同步

概念：借助现有的Happens-Before顺序来确保对象的可见性。将Happens-Before的程序顺序和其他某个顺序规则（通常是监视器锁规则 或者 volatile变量规则 结合起来），从而对某个未被锁保护的变量的访问操作进行排序，从而提供程序的性能。

缺点：这项技术对语句的顺序非常敏感，因此很容易出错，只有当最大程度提升某些类性能的时候，才应该使用这项技术。



### 发布

除了不可变对象外，使用另外一个线程初始化的对象，通常是不安全的，除非对象的发布操作在 使用该对象的线程开始使用之前 执行。

#### 延迟初始化（并且避免同步）

![image-20190209174019245](https://ws2.sinaimg.cn/large/006tNc79gy1g00b7fas54j30o807ogmq.jpg)

- 使用静态初始化器：静态初始化器是由JVM在类的初始化阶段执行，即类被加载后且被线程使用之前。从而不需要进行同步
- 在该示例中，JVM将推迟ResourceHolder的初始化操作，直到开始使用这个类时，才初始化。