# 类加载机制

虚拟机把**描述类的数据**从class文件加载到内存，并且进行校验、解析、初始化。最终形成可以直接使用的Class对象，这就是类加载机制。



## 类加载的时机

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，共7个阶段。其中验证、准备、解析 3个部分统称为**连接**。这7个阶段的发生顺序如图：

![image-20191020212815518](https://tva1.sinaimg.cn/large/006y8mN6gy1g84zkkq7f7j31720hmqb5.jpg)

加载、验证、准备、初始化、卸载 这5个阶段的顺序是确定的。类的加载过程必须按照这个顺序来执行。

而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始。这是为了支持java语言的运行时绑定（称为“动态绑定”）。

注意：这些过程只是按部就班的开始，而不是按部就班的完成。强调这点是因为这些阶段通常是相互交叉的运行，通常会在一个阶段执行的过程中调用、激活另外一个阶段。



**有且仅有5种情况，必须对类进行初始化（而加载、验证、准备 自然需要在此之前开始）**

- 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：
  - 使用new关键字实例化对象的时候
  - 读取或设置一个类的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）
  - 调用一个类的静态方法
- 对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
- 当初始化一个类的时候，如果发现其父类没有初始化，那么先触发父类的初始化
- 当虚拟机启动时，用户需要指定一个要执行的主类（含main()方法的类），虚拟机就会先初始化这个主类。
- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic，REF_putStatic 、REF_invokeStatic的方法的句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。

这5种场景的行为称为对一个类的主动引用。除此之外，所有对类的引用行为都不会触发初始化，称为被动引用。

被动引用的例子如下：

```java
public class SuperClass {

    static {
        System.out.println("SuperClass init");
    }

    public static int value = 123;
}

public class SubClass extends SuperClass {

    static {
        System.out.println("SubClass init");
    }
    
}

public class InitDemo {

    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }

}

输出
SuperClass init
123  
```

对于静态字段，只有直接定义了这个字段的类才会被初始化。因此子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。



接口的初始化和类的初始化的不同：

- 当一个类初始化时，要求其父类已经初始化了
- 但是一个接口初始化时，并不要求父接口全部完成初始化。只有只用到父接口时（比如使用父接口中的常量），才会初始化父接口。

```java
/**
 * 父接口
 * @author huangy on 2019-10-20
 */
public interface SuperInterface {

    Node2 tem = new Node2();

    /**
     * 如果父接口初始化，则会初始化对应的成员属性，因此Node的构造函数会被调用
     */
    Node node = new Node();
}


/**
 * 子接口
 * @author huangy on 2019-10-20
 */
public interface SubInterface extends SuperInterface {

    /**
     * 使用到父类的final静态常量。
     * 这里值得注意的是，如果引用了父类的String类型常量，则无法触发父接口初始化
     */
    Node2 node2 = SuperInterface.tem;
}

public class InitInterfaceDemo {

    public static void main(String[] args) {
        System.out.println(SubInterface.node2);
    }

}

public class Node2 {
}

public class Node {

    public Node() {
        System.out.println("node init");
    }
}

输出
node init  （表示父接口初始化了）
```







## 类加载过程

### 加载

在加载阶段，虚拟机需要完成3个事情：

- 通过一个类的全限定名，获取一个类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口

没有指定二进制字节流从哪里获取，因此可以在运行时动态生成字节流，然后进行**加载**。在java.lang.reflect.Proxt中，就是使用ProxyGenerator.generateProxyClass为特定接口生成“*$Proxy”的代理类的二进制字节流。利用这种方式实现动态代理。

相对于类加载的其他阶段，加载阶段是开发人员可控性最强的，因为加载阶段可以使用用户自定义的类加载器完成，开发人员可以通过自定义类加载器控制字节流的获取方式。（即重写一个类加载器的loadClass()方法）。



对于数组类而言，情况就有所不同，数组类本身类加载器创建，它是由Java虚拟机直接创建的。但是数组类和类加载器仍然有很密切的的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终是要靠`类加载器`去创建。

一个数组类的创建过程遵循以下规则：

- 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是`引用类型`，那就`递归`采用本节中定义的加载过程去加载这个组件类型，`数组将在加载该组件类型的类加载器的类名称空间上被标识`
- 如果数组的组件类型不是`引用类型`（例如int[]数组），Java虚拟机将会把数组`标记为与引导类加载器关联`
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public



**加载阶段完成后，虚拟机外部的二进制字节流就存储在方法区之中（方法区中数据存储格式由虚拟机自行定义），然后在内存中实例化一个Class对象（在HotSpot虚拟机中，该对象存放在方法区），这个对象将作为程序访问方法区中类型数据的接口**



### 验证

验证是连接阶段的第一步。这一阶段的目的是确保class文件中的字节流的信息符合虚拟机的要求，并且不会危害虚拟机的安全。验证阶段大概分为4个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。

#### 文件格式验证

字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。比如说：

- 是否以魔数开头
- 主、次版本号是否在当前虚拟机的处理范围内
- 常量池的常量是否有不被支持的常量类型
- 指向常量的各种索引值是否有指向不存在的常量或者 不符合类型的常量

文件格式验证的目的是保证输入的字节流能正确解析并且存储在方法区之内。这个阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储。后面的3个阶段都是基于方法区的数据结构进行的，不再直接操作字节流。



#### 元数据的验证

这个阶段是对字节码的描述的信息进行语义分析，以保证其描述的信息符合Java语言规范。比如

- 这个类是否有父类
- 这个类是否继承了不允许被继承的类（比如final修饰的类）



#### 字节码验证

通过数据流和控制流分析，确定程序语义是合法的。（也就是对类的方法体进行校验）。

- 例如把对象赋值给没有继承关系的类型，是不合法的





#### 符号引用验证

符号引用验证发生在虚拟机将符号引用转化为直接引用的时候。校验的内容如下：

- 符号引用中通过字符串描述的全限定名能否找到对应的类

符号引用验证的目的是确保解析动作（解析阶段会把符号引用转化为直接引用）能正常执行。