# JVM结构

Java虚拟机在执行java程序的过程中，会把它的内存划分为若干个不同的运行时数据区域，如图所示：

![image-20191023234041536](https://tva1.sinaimg.cn/large/006y8mN6gy1g88k9amw8sj30zy0u07ic.jpg)





## 程序计数器PC

程序计数器是一块较小的内存空间，字节码解释器工作时，就是通过改变这个计数器的值来选取下一条要执行的字节码指令。

- 如果线程执行的是java方法，计数器存储的**正在执行**的虚拟机字节码地址
- 如果线程执行的是native方法，那么这个计数器值为空（Undefined）
- 为了线程切换后，会回到正确的执行位置，每个线程都需要有一个独立的程序计数器（线程私有的）
- 唯一不会报出Out of Memory的区域



## 虚拟机栈

### 概念

Java虚拟机栈也是线程私有的。它的生命周期与线程相同。

虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时，会创建一个栈帧，该栈帧用于存储局部变量表、操作数栈、动态链接方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧入栈到出栈的过程。

经常有人说“栈内存”，就是指虚拟机栈。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlow异常。

如果虚拟机栈的大小可以动态扩展，但是虚拟机无法申请到足够的内存，就会抛出OutOfMemory异常。



### 栈帧

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。



#### 局部变量表

存放编译器可知的基本数据类型、对象引用、返回地址类型。

其中，64位长度的long和double会占用2个局部变量空间(slot)，其余的数据类型只占用1个。

局部变量表所占用的内存空间在编译器完成分配。当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的（因为过了编译期。。），在方法运行期间不会改变局部变量表的大小。



#### 返回值

如果有返回值的话，压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。



#### 操作数栈

- 操作数栈的最大深度在编译的时候已经确定（写入方法区code属性的max_stacks项中）

- 操作数栈的的元素可以是任意Java类型，包括long和double，32位数据占用栈空间为1，64位数据占用2。

- 方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。



#### 动态链接

- 每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。

- Class文件的常量池中有大量的符号引用，字节码调用方法的指令将这些符号引用作为参数。这些符号引用一部分在类加载阶段或者第一次使用阶段转化为直接引用，这种转化称为静态解析。另一部分将会在每一次运行期间转换为直接引用，这种转化称为动态解析。

- 线程私有的。



## 本地方法栈 

- 本地方法栈和虚拟机栈的功能相似，虚拟机栈为虚拟机执行**Java**方法服务，本地方法栈则是为虚拟机使用到的本地方法服务。
- 线程私有



## Java堆

- Java堆是虚拟机管理的内存中最大的一块
- Java堆是所有线程共享的区域
- 在虚拟机启动时创建
- 此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。存放new生成的对象和数组
- Java堆是垃圾收集器管理的内存区域，因此很多时候称为“GC堆”
  - 从内存回收角度讲，现在的垃圾收集器打多使用分代收集，把内存划分为新生代，老年代
  - 从内存分配角度讲，线程共享的java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer TLAB）
- 堆在物理上可以是不连续的内存空间，只不过逻辑上是连续的即可







## 方法区

概念：与Java堆一样，各个线程共享的区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。有一个别名“Non-Heap” (非堆)

### 版本差异

在JDK1.6及之前，运行时常量池是方法区的一个部分，同时方法区里面存储了类的元数据信息、静态变量、即时编译器编译后的代码（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息）等。

在JDK1.7及以后，JVM已经将运行时常量池从方法区中移了出来，在JVM堆开辟了一块区域存放常量池。

### 方法区和永久代的关系

在Java虚拟机规范中，方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择不在方法区实现垃圾回收与压缩。这个版本的虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。所以不同的JVM厂商，针对自己的JVM可能有不同的方法区实现方式。

在HotSpot中，设计者将方法区纳入GC分代收集。HotSpot虚拟机堆内存被分为新生代和老年代，对堆内存进行分代管理，所以HotSpot虚拟机使用者更愿意将方法区称为老年代。

方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。

### 运行时常量池

- 是方法区的一部分

- 存放编译期生成的各种字面量和符号引用

- Class文件中除了存有类的版本、字段、方法、接口等描述信息，还有一项是常量池，存有这个类的 编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池中。

###元空间

HotSpot虚拟机在1.8之后已经取消了永久代，改为元空间，**类的元信息**被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。

这项改造也是有必要的：

- 永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。
- 永久代中的元数据的位置也会随着一次full GC发生移动，比较消耗虚拟机性能。同时，HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。
- 将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化。





##  JVM的启动过程

JVM的启动流程大致分为几个步骤：

### 配置JVM的装载环境

Java代码执行时，需要一个JVM环境，JVM环境的创建包括两部分，JVM.dll文件的查找和装载。

- JVM.dll文件的查找
- JVM.dll文件的装载：



### 解析虚拟机参数

装载完JVM以后，需要对启动参数进行解析，其实在装载JVM环境的过程中，已经解析了部分参数。

- 设置线程栈大小：

- 执行Java main方法：

Java Main函数的执行流程大致如下：

- 新建JVM实例：

- 加载主类的class
- 查找main方法
- 执行main方法





**JAVA OOM**（**Out Of Memory Error**，内存溢出）：

1、概念：堆内存没有足够空间分配给对象，并且垃圾收集器也没有空间回收时，就会抛出这个错误。

2、造成OOM的原因：

​	（1）在初始化JVM的阶段，设置给JVM可用的内存太少了

（2）用完的对象没有释放，导致内存泄漏。

3、OOM有哪几种类型：

​	（1）堆空间不够大造成溢出

​	（2）虚拟机栈的深度不能够扩展

（3）方法区溢出



九、**JVM**退出的几种情况：

1、执行了System.exit(int status)方法

2、程序执行结束

3、程序在执行过程中遇到了异常或者错误而终止运行（main方法里面throws抛出的异常，将会被JVM捕获，然后JVM就会异常退出了）

4、操作系统出现错误导致Java 虚拟机进程终止



十、直接内存：

1、直接内存不是Java虚拟机运行时数据区的一部分，而是计算机本身的内存。利用NIO可以使用Native函数库直接分配堆外内存，然后通Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能提升性能，因为避免了在Java堆和Native堆中来回复制数据的开销。

2、本机直接内存的分配不会受到Java堆大小的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现Out of Memory异常。



##HotSpot虚拟机

### Java对象创建过程

- 虚拟机遇到一条new指令时，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经加载、连接和初始化。如果没有，就执行该类的加载过程。

- 为该对象分配内存
  - 设Java堆是规整的，所有用过的内存放在一边，空闲的内存放在另外一边，中间放着一个指针作为分界点的指示器。那分配内存只是把指针向空闲空间那边挪动与对象大小相等的距离，这种分配称为“指针碰撞”
  - 假设Java堆不是规整的，用过的内存和空闲的内存相互交错，那就没办法进行“指针碰撞”。虚拟机通过维护一个列表，记录哪些内存块是可用的，在分配的时候找出一块足够大的空间分配给对象实例，并更新表上的记录。这种分配方式称为“空闲列表“。
  - 使用哪种分配方式由Java堆是否规整决定。Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。
  - 分配对象保证线程安全的做法：虚拟机使用CAS配上失败重试的方式保证更新操作的原子性。（实际上还有另外一种方案：每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，TLAB。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才进行同步锁定。虚拟机是否使用TLAB，由-XX:+/-UseTLAB参数决定）

- 虚拟机为分配的内存空间初始化为零值（默认值）

- 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到对象的元数据信息、对象的Hash码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中。

- 执行<init>方法，把对象按照程序员的意愿进行初始化。



### 对象的定位访问的方式

通过引用如何去定位到堆上的具体对象的位置

#### 句柄

使用句柄的方式，Java堆中将会划分出一块内存作为作为句柄池，引用中存储的就是对象的句柄的地址。而句柄中包含了对象实例数据和对象类型数据的地址。

![image-20190223184723669](https://ws4.sinaimg.cn/large/006tKfTcgy1g0gjtkx8tpj313m0h0te9.jpg)



#### 直接指针

使用直接指针的方式，引用中存储的就是对象的地址。Java堆对象的布局必须必须考虑如何去访问对象类型数据。

![image-20190223184746278](https://ws2.sinaimg.cn/large/006tKfTcgy1g0gjtx9oglj313a0ic0y0.jpg)



#### 两种方式各有优点

- 使用句柄访问的好处是引用中存放的是稳定的句柄地址，当对象被移动（比如说垃圾回收时移动对象），只会改变句柄中实例数据指针，而引用本身不会被修改。
- 使用直接指针，节省了一次指针定位的时间开销。



### HotSpot的GC算法实现



#### HotSpot怎么快速找到可达对象

HotSpot使用一组称为OopMap的数据结构。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在栈和寄存器中哪些位置是引用。这样子，在GC扫描的时候，就可以直接知道哪些是可达对象了。



#### 安全点

- HotSpot只在特定的位置生成OopMap，这些位置称为安全点。

- 程序执行过程中并非所有地方都可以停下来开始GC，只有在到达安全点是才可以暂停。

- 安全点的选定基本上以“是否具有让程序长时间执行“的特征选定的。比如说方法调用、循环跳转、异常跳转等。具有这些功能的指令才会产生Safepoint。



#### 抢占式中断

在GC发生时，首先把所有线程中断，如果发现有线程不在安全点上，就恢复线程，让它跑到安全点上。



#### 主动式中断

GC需要中断线程时，不直接对线程操作，仅仅设置一个标志，各个线程执行时主动去轮询这个标志，当发现中断标记为真就自己中断挂起。轮询标记的地方和安全点是重合的。



#### 安全区域

一段代码片段中，对象的引用关系不会发生变化，在这个区域中任何地方开始GC都是安全的。在线程进入安全区域时，它首先标志自己已经进入安全区域，在这段时间里，当JVM发起GC时，就不用管进入安全区域的线程了。在线程将要离开安全区域时，它检查系统是否完成了GC过程，如果完成了，它就继续前行。否则，它就必须等待直到收到可以离开安全区域的信号。



#### GC时为什么要停顿所有Java线程？

因为GC先进行可达性分析。可达性分析是判断GC Root对象到其他对象是否可达，假如分析过程中对象的引用关系在不断变化，分析结果的准确性就无法得到保证。



#### CMS收集器

##### 概念

一种以获取最短回收停顿时间为目标的收集器。一般用于互联网站或者B/S系统的服务端。基于标记-清除算法的实现，不过更为复杂，整个过程为4个步骤：

- 初始标记：标记GC Root能直接引用的对象
- 并发标记：利用多线程对每个GC Root对象进行tracing搜索，在堆中查找其下所有能关联到的对象。

- 重新标记：为了修正并发标记期间，用户程序继续运作而导致标志产生变动的那一部分对象的标记记录。

- 并发清除：利用多个线程对标记的对象进行清除



由于耗时最长的并发标记和并发清除操作都是用户线程一起工作，所以总体来说，CMS的内存回收工作是和用户线程一起并发执行的。



##### 缺点

- 对CPU资源占用比较多。可能因为占用一部分CPU资源导致应用程序响应变慢。

- CMS无法处理浮动垃圾。在并发清除阶段，用户程序继续运行，可能产生新的内存垃圾，这一部分垃圾出现在标记过程之后，因此，CMS无法清除。这部分垃圾称为“浮动垃圾“

- 需要预留一部分内存，在垃圾回收时，给用户程序使用。

- 基于标记-清除算法，容易产生大量内存碎片，导致full GC（full GC进行内存碎片的整理）



### 对象头部分的内存布局

HotSpot的对象头分为两部分，第一部分用于存储对象自身的运行时数据，比如哈希码、GC分代年龄等。另外一部分用于指向方法区对象类型数据的指针。

