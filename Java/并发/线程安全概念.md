### 对象的状态

指的是对象的状态变量（实例域或静态域）中的数据。对象的状态可能包含所依赖的其他对象的域。



### 线程安全性

概念：在多线程中，程序能够正确的运行。

重点：

- 无状态对象，一定是线程安全的
- 要编写线程安全的代码，其核心在于对状态访问操作进行管理，特别是对共享 和 可变 状态 的访问。（对象如果是不能被并发访问的，并且保证对该对象的访问是串行的）
- 需要在检查的状态之前加锁
- 要保持状态的一致性（数据处于一种语义上的有意义且正确的状态），就需要在单个原子操作中，更新所有相关的状态变量
- **当类的不变性条件涉及多个状态变量时，每个变量都必须由同一把锁来保护。**（多个状态变量，来完成1件事情时，这几个状态变量都必须是同一把锁保护）
- 当执行时间长的计算 或者 可能无法快速完成的操作（如I/O），一定不要持有锁
- 在没有同步的情况下，编译器、处理器及运行时等都可能对操作的执行顺序进行调整。（换话说，有同步就不会进行调整，应该是通过内存屏障解决的）
- 64位数值变量（double和long）的线程安全性：JVM内存模型要求，变量的读操作 和写操作都必须是原子性的。但对于非volatile类型的long和double变量，JVM允许将64位的读操作（或者写操作）分解为2个32的位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，很可能读取到某个值的高32位和另外一个值的低32位。因此，在多线程中使用共享且可变的long或double类型的变量是不安全的，需要使用volatile声明 或者 使用锁。
- 尽量将域声明为final，除非它们是可变的
- 封装有助于管理复杂性





### 竟态条件

概念：多线程同时访问，并且由于不正确的操作序列而出现不正确的结果。典型的竟态条件有“先检查后执行”，实际上先检查获得的结果可能已经失效了，然而还根据这个结果来做出判断并且执行操作。



### 内置锁、监视器锁

同一个东西，就是实现同步的锁



### 重入

概念：获取一个自己持有的锁，可以成功

实现方式：重入的一种实现方法是为每一个锁关联一个计数值和所有者线程，当计数值为0时，这个锁就认为没有被任何线程持有。当线程请求一个未被持有的锁时，JVM记录下锁的持有者，并且计数值置为1。如果同一个线程再次获取这个锁，计数值会递增。而当线程退出同步代码块时，锁会相应的递减。当计数值为0时，锁就被释放了。

重要作用：

（1）避免死锁。比如在同步函数中递归调用，如果是不可重入，会造成死锁。



### 内存可见性

概念：一个线程修改了对象的状态后，释放锁，另外一个线程获取到锁，并且能看到该对象的状态变化（最新值）。

要点：访问同一个共享且可变的变量时，必须要使用同一把锁，这样子保证对该变量的访问是串行的，不会获取到失效值。



### 发布

发布指的是 对象能够在当前作用域之外的代码中使用



### 逸出

某个不应该被发布的对象被发布了



### 线程封闭

不共享数据，数据仅在线程内访问。作用是可以避免同步，2种常见的方式

- 栈封闭：在栈中生成的变量，比如说局部变量，一定是线程私有的，从而保障线程安全
- ThreadLocal：让每一个线程拥有自己的变量



#### Ad-hoc线程封闭

维护线程的封闭性完全由程序来实现。



### 不可变对象

一定是线程安全的。满足下面几种状态才可以称为不可变对象：

- 对象创建以后，状态不能修改
- 对象的所有域都是final类型
- 对象是正确创建的（在对象创建期间，this引用没有逸出）



### 线程安全类的3要素

- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件（这些变量在并发条件下也能保证类的正确运行，要达到怎样的条件）
- 建立对象状态的并发访问管理策略



### 实例封闭

指将一个对象封装到另外一个对象中。

这样子被封装对象的所有代码访问路径都是已知的，更易于对代码进行分析，从而保障线程安全性。



### 死锁

概念：多个线程因为竞争资源而处于永久阻塞状态，若无外力作用，这些线程都无法向前推进。



#### 锁顺序死锁

概念：两个线程试图以不同的顺序获得相同的锁，导致死锁。

解决方法：不同线程在获取多个锁时，采用一致的顺序



#### 动态顺序死锁

概念：获取锁的顺序是动态的，导致的死锁。

典型的例子是转账:

```java
private static void transfer(Object fromAccount, Object toAccount, Long amount) {
        synchronized (fromAccount) {
            synchronized (toAccount) {
                // ... 转账操作
            }
        }
    }
```

如果两个线程同时转账，其中一个线程X向Y转账，另外一个线程Y向X转账，那么就会发生死锁。

解决方法：保证获取这两个锁以相同的顺序

```java
private static Object lock = new Object();

    private static void transfer(Object fromAccount, Object toAccount, Long amount) {
        // 计算锁的hash值，不同对象基本不一样，通过hash值来判断获取锁顺序，从而避免死锁
        int fromHashCode = System.identityHashCode(fromAccount);
        int toHashCode = System.identityHashCode(toAccount);

        if (fromHashCode < toHashCode) {

            synchronized (fromAccount) {
                synchronized (toAccount) {
                    // ... 转账操作
                }
            }

        } else if (fromHashCode > toHashCode) {

            synchronized (toAccount) {
                synchronized (fromAccount) {
                    // ... 转账操作
                }
            }

        } else {
            /*
             * hash值相同的情况下（hash冲突了），另外加1把锁
             * 保证同一时间只有一个线程获取到2把锁
             */
            synchronized (lock) {
                
                synchronized (fromAccount) {
                    synchronized (toAccount) {
                        // ... 转账操作
                    }
                }
            }
        }
    }
```



#### 在协作对象之间发生死锁

不同对象之间，以不同的顺序获取相同的锁，也会发生死锁。通常出现在持有锁时调用某个外部方法，而这个外部方法有去获取另外一把锁。



#### 资源死锁

多个线程持有彼此正在等待的资源，而又不释放自己已持有的资源时，会发生“资源死锁”。

实例：一段代码需要连接2个数据库。线程A和线程B同时运行了该代码。A持有数据库D1的连接，并且等待数据库D2的连接；B持有数据库D2的连接并且等待数据库D1的连接。

解决方法：资源池越大，出现这种情况的可能性越小

##### 线程饥饿死锁

概念：是资源死锁的一种，主要是在有界线程池中，一个任务提交了另外一个任务。当只剩下一个线程时，会发生线程饥饿死锁。

解决方法：有界线程池 和 相互依赖的任务 不能一起使用。



#### 开放调用

调用某个方法时不需要持有锁。比如说之前是整个方法加锁了，现在缩小同步块的范围，从而避免死锁。



#### 定时锁

利用显式锁设置超时时间，也可以有效避免死锁。（当获取锁超时，可以重试。总比重启系统好得多）



#### 通过线程转储信息来分析死锁

线程转储包括了各个运行中的线程的栈追踪信息、每个线程持有哪些锁、在哪些栈帧中获得这些锁、被阻塞的线程等待获取哪一个锁。

生成线程转储之前，JVM将在等待关系图中通过搜索循环来找出死锁。如果发现一个死锁，则获取相应的死锁信息。



### 其他活跃性问题

#### 饥饿

概念：线程无法访问它们所需要的资源，而无法继续执行。

实例：修改一些线程的优先级，导致其他线程发生”饥饿“（一直得不到执行）

#### 活锁

概念：线程不断执行重复的操作，并且失败，阻碍程序正常运行。

实例：两个过于礼貌的路人相遇了，他们彼此都让出当前这条路，然而又在另外一条路上面相遇了，因此他们就这样反复避让下去。

解决方法：引入随机性



###原子性

原子性可以应用于除long和double以外的所有基本类型的读写操作。对于"读"或者"写"，可以保证它们的原子性。但是JVM可以把64位的long和double的读取(或者写入)当做两个分离的32位操作来执行，这样子就无法保证"读"或者"写"的原子性了。



### 临界区

只能有1个线程同时访问的区域。