# synchronized

synchronized的知识结构如下：

![image-20191013113605679](https://tva1.sinaimg.cn/large/006y8mN6gy1g7wf4a6747j31hy0u0e0j.jpg)

关于锁我们知道它可以让临界区互斥，但它还有另一个重要功能，锁的内存语义。

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
当线程获取锁时，JMM会把该线程对应的本地内存置为无效。

线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。
线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。
线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。



## 每个对象作为锁

java中每个对象都可以作为锁。

- 普通方法：锁是当前实例对象
- 静态方法中：锁是当前类的class对象
- 同步方法块：锁是synchronized括号里面的对象



## 实现原理

JVM基于进入和退出Monitor（监视器）对象来实现方法同步和代码块同步，但两者的实现细节不一样。

代码块的同步是使用monitorenter和monitorexit指令实现的，而方法的同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

monitorenter指令插入到代码块的起始位置，monitorexit指令插入到代码块结束和异常的位置。

JVM保证monitorenter一定会有一个monitorexist对应，不然就死锁了。

每一个对象都有一个monitor（监视器）与之关联。当一个monitor被持有后，它将处于锁定状态。当线程执行到monitorenter，线程将尝试获取对象关联的monitor的所有权，即尝试获取对象的锁。



### Java对象头

synchronize使用的锁是存储在**java对象头**里面的。如果对象是数组类型，则虚拟机用3**字宽**存储对象头；如果对象是非数组类型，则虚拟机使用2字宽存储对象头。

在32位虚拟机中，1字宽等于4字节。

![image-20191013115654950](https://tva1.sinaimg.cn/large/006y8mN6gy1g7wfpxwsc6j31je0ckn30.jpg)

java对象头的mark world存储对象的HashCode、分代年龄、锁状态、锁标志位、是否偏向锁。32位的JVM的mark world存储结构如图：

![image-20191013120238571](https://tva1.sinaimg.cn/large/006y8mN6gy1g7wfvw8c3jj31k004u418.jpg)

在运行期间，mark world里面的数据会随着**锁标志位**的变化而变化，如图：

![image-20191013120416195](https://tva1.sinaimg.cn/large/006y8mN6gy1g7wfxl31uhj31jq0fcwld.jpg)



## 锁升级与对比

Java SE1.6为了减少获得锁和释放锁带来的性能损耗，引入了“偏向锁”和“轻量级”锁。在java SE 1.6中，锁一共有4种状态，级别从高到底依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。这几个状态会随着锁竞争加剧而逐渐升级。

**锁可以升级，但不能降级。**意味着偏向锁升级为轻量级锁之后，不能降级为偏向锁。为什么这样子做呢？这样子是为了提高获取锁和释放锁的效率。下面会详细分析。



### 偏向锁

HotSpot的作者经研究发现，大多数情况下，锁不仅不存在多线程竞争，并且总是由同一个线程获得。这样子每次获取锁都进行同步，代价也太大了。**为了让线程获取锁的代价更低**而引入了偏向锁。



####偏向锁的获取

当一个线程访问同步代码块，并且获得到锁的时候，对象头mark world中会设置为偏向锁，并且记录该线程的ID（同时栈帧中锁记录会存储偏向的线程ID）。以后该线程在进入同步代码块的时候，同步块不需要使用CAS进行加锁，只需要简单测试一下对象头mark world是否存储着指向当前线程的偏向锁。

如果测试成功，那就表示线程已经获取到锁了。

如果测试失败，那就再看下对象头mark world中还是不是偏向锁。

​	如果是的话，则尝试使用CAS将偏向锁指向当前线程。、

​	如果不是，则使用CAS竞争锁。



#### 偏向锁的撤销

偏向锁使用一种等待竞争出现才释放锁的机制，所以当其他线程尝试释放锁时，持有偏向锁的线程才会释放偏向锁。

下图是发生竞争的情况下，进行偏向锁的撤销：

![image-20191013130101306](https://tva1.sinaimg.cn/large/006y8mN6gy1g7whkmy9f0j30u00u0gxz.jpg)

- 判断Mark Word中是否有指向自己的线程ID，否。
- 判断当前锁是否为偏向锁，是。那么线程2会用CAS替换来尝试获取锁。 CAS替换Mark Word成功表示获取偏向锁成功, 这里由于对象头中Mark Word已经指向了线程1, 所以替换失败, 需要**进行撤销操作**。
- 撤销偏向锁, 需要等待全局安全点(safepoint)，就是当前时间点上没有字节码正在执行。
- 撤销的时候需要等线程1全部跑完run方法，然后暂停线程1。如果线程1已经终止了，则将锁对象的对象头设置为无锁状态(方便下一个线程进来)。如果对象1还未终止，恢复线程1，并将锁升级为轻量级锁，然后和线程2一起CAS竞争轻量级锁。



我个人认为，拥有偏向锁的线程不会自动释放偏向锁，第一个线程申请偏向锁的时候会成功，第二个线程来申请偏向锁的时候，不管第一个线程执行完毕还是未完毕，都要进行一次撤销或者升级的操作，因为当时Mark Wrod中保存的指针不是线程2，所以只有撤销为无锁状态，线程2才能成为新的偏向锁偏向的线程
锁的对象头中偏向着线程1，因为它不知道线程1什么时候来，所以一直偏向着，就算线程1已经死亡了。所以撤销锁的时候，先检查对象头所指向的线程是否存活，如果不存活，那么偏向锁撤销为无锁，如果存活，那么线程1目前没有拿着锁而在干别的事情，这样锁就在不同时间段被不同线程访问了升级为轻量级锁，线程2就拿到了锁。





#### 关闭偏向锁

偏向锁是默认开启的，而且开始时间一般是比应用程序启动慢几秒，如果不想有这个延迟，那么可以使用-XX:BiasedLockingStartUpDelay=0；
如果不想要偏向锁，那么可以通过-XX:-UseBiasedLocking = false来设置；



### 轻量级锁



#### 轻量级加锁

- 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word拷贝到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。
- 如果成功，当前线程获得锁
- 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
- 如果使用自旋锁也获取不到锁，那么它就会修改markword，标识为重量级锁，表示该升级为重量锁了。



等待轻量锁的线程不会阻塞，它会一直自旋等待锁。这就是自旋锁。

尝试获取锁的线程，在没有获得锁的时候，不被挂起，而转而去执行一个空循环，即自旋。在若干个自旋后，如果还没有获得锁，则才被挂起。

获得锁，则执行代码。虽然自旋可以防止阻塞，**节省从内核态到用户态的开销**，但是如果长时间自旋，则会导致CPU长时间做一个同样的无用循环操作。浪费CPU的资源。这时候引入了自适应自旋。





#####自适应自旋锁

此操作为了防止长时间的自旋，在自旋操作上加了一些限制条件。

- 比如一开始给线程自旋的时间是10秒，如果线程在这个时间内获得了锁，那么就认为这个线程比较容易获得锁，就会适当的加长它的自旋时间。
- 如果这个线程在规定时间内没有获得到锁，并且阻塞了。那么就认为这个线程不容易获得锁，下次当这个线程进行自旋的时候会减少它的自旋时间



####轻量级解锁

轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头。
如果成功，则表示没有竞争发生。成功替换，等待下一个线程获取锁。
如果失败，表示当前锁存在竞争（因为自旋失败的线程已经将对象头中的轻量级锁00改变为了10），锁就会升级为重量级锁。

因为**自旋会消耗CPU，为了避免过多的自旋**，一旦锁升级成重量级锁，就不会再 恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后 会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。


下图是两个锁同时竞争，导致锁升级的流程图：

![image-20191013132634997](https://tva1.sinaimg.cn/large/006y8mN6gy1g7wib8dsfgj30us0u07jx.jpg)

因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再 恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后 会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。



### 重量级锁

- 重量级锁是JVM中为基础的锁实现。在这种状态下，JVM虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。
- Java线程的阻塞以及唤醒，都是依靠操作系统来完成的。举例来说，对于符合posix接口的操作系统(如macOS和绝大 部分的Linux)，上述操作通过pthread的互斥锁(mutex)来实现的。此外，这些操作将涉及系统调用，**需要从操作系统的用户态切换至内核态**，其开销非常之大。
- 为了尽量避免昂贵的线程阻塞、唤醒操作，JVM会在线程进入阻塞状态之前，以及被唤醒之后竞争不到锁的情况 下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。
  





### 锁的对比

![image-20191013133725683](https://tva1.sinaimg.cn/large/006y8mN6gy1g7wimitss3j31lg0h2tlx.jpg)





## 总结

Java虚拟机中synchronized关键字的实现，按照代价由高到低可以分为重量级锁、轻量锁和偏向锁三种。

- 重量级锁会阻塞、唤醒请求加锁的线程。**它针对的是多个线程同时竞争同一把锁的情况**。JVM采用了自适应自旋，来避免线程在面对非常小的synchronized代码块时，仍会被阻塞、唤醒的情况。
- 轻量级锁采用CAS操作，将锁对象的mark world替换为一个指针，指向当前线程栈上的一块空间（锁记录），存储着锁对象原本的mark world。**它针对的是多个线程在不同时间段申请同一把锁的情况**。
- 偏向锁只会在第一次请求时采用CAS操作，在锁对象的标记字段中记录下当前线程的内存地址。在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。**它针对的是锁仅会被同一线程持有的情况**。







## 参考

《并发编程艺术》

https://blog.csdn.net/sinat_34976604/article/details/88757084

https://blog.csdn.net/qq_39487033/article/details/84261640