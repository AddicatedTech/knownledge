# ConcurrentLinkedQueue



## 源码



### 入队列

通过CAS算法实现入队，保证线程安全。

如果一个线程要入队，那么它首先获取队列的尾节点，设置尾结点的下一个节点为入队节点，但这时可能有另外一个线程插队，那么尾节点就会发生变化，因此当前线程入队失败，然后当前线程会重新获取尾节点进行重试。

![image-20191123130501940](https://tva1.sinaimg.cn/large/006y8mN6gy1g97w3gab7pj31ia0ts7wh.jpg)



### HOPS设计意图

tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点有可能是tail节点，也有可能是tail节点的尾节点。**只有tail节点和尾节点的距离大于等于HOPS常量的值**，才更新tail节点。

为什么要这么复杂的设计呢？完全可以实现成如下方案：

![image-20191123125917108](https://tva1.sinaimg.cn/large/006y8mN6gy1g97vxi1qhmj316e0f075x.jpg)

如果这样子实现，代码了会非常少，而且清晰易懂，但是这么做有个缺点：每次都需要循环CAS更新tail节点。

如果能减少CAS更新tail节点的次数，就能提高入队效率。所以doug lea作者使用hops变量来减少tail节点的更新频率。

通过减少CAS更新tail节点，能提高入队效率，但是每次定位尾结点的时间将会变长。但是总体来说还是提高了效率，因为CAS写操作的开销远远大于读操作。





### 出队列

出队列就是从队列中弹出一个元素，并清空该节点对元素的引用。

![image-20191123130652160](https://tva1.sinaimg.cn/large/006y8mN6gy1g97w5czuw5j319c0tytxu.jpg)

从图中可知，并不是每次出队都要更新head节点，

- 当head节点里面有元素时，直接弹出head节点的元素
- 当head节点里面没有元素时，出队操作才会更新head节点

这种做法也是通过hops变量来减少CAS更新head的操作，从而提高出队效率。



首先获取head节点，判断该节点的元素是否为空，

- 如果为空，则表示其他线程进行了出队操作，把该节点的元素取走了，则获取head下一个节点。

- 如果不为空，则使用CAS将该节点的元素item更新为null
  - 如果CAS成功，直接返回元素
  - 否则，重新获取头节点，重试