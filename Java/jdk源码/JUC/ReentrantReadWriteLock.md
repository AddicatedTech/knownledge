# ReentrantReadWriteLock

简单了解一下ReentrantReadWriteLock

- 读锁是个共享锁，写锁是个独占锁。读锁同时被多个线程获取，写锁只能被一个线程获取。读锁与写锁不能同时存在。
- 一个线程可以多次重复获取读锁和写锁
- 锁升级：不支持升级。获取读锁的线程去获取写锁的话会造成死锁。
- 重入数：state表示重入数，前16位表示读锁的总数量，后16位表示写锁的总数量
- 支持公平与非公平两种模式



AQS维护了一个int值，表示同步状态；对于ReentrantLock，state会在0与1之间变化，1表示已被占有后续线程入队列等待，0表示free。对于CountDownLatch，会先将state赋予个大于0的值，在该值变为0后唤醒等待队列中的线程。那么如何用它来即表示读锁又表示写锁呢？读锁我们是允许多个线程同步运行的，我们还允许重入，那么拿什么来记录每个线程读锁的重入数？

针对上面两个问题，**对于同步状态status，高16位表示所有线程持有的读锁总数，低16位为一个线程的写锁总数，包括重入**。





## 源码



### 写锁

#### 写饥饿

表示由于读锁一直占用资源，导致线程无法正常获得写锁。

解决方案：如果当前有线程获取写锁，那么资源已经被前面获取读锁的线程占有了，那么只要等这些已有读锁的线程，就好了。新的获取读锁线程，就阻塞一下。从而避免写饥饿



获取写锁。

1，持有写锁的线程可以再次获取写锁。

2，持有写锁的线程可以获取读锁 

3、同一个线程，获取了读锁，再获取写锁，会导致死锁





## 参考

https://blog.csdn.net/sinat_34976604/article/details/80971628